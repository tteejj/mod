# core-data.ps1
# (Content from core-data-ps1 (11).txt, with migrations from Pmc Mod Base.txt for task and Excel copy job logic)

# Core Data Management Module
# Projects, tasks, todos, command snippets, Excel copy jobs

#region Data Model Initialization

# Initialize the unified data model
$script:Data = @{
    Projects = @{}      # Master project repository with full TimeTracker template support
    Tasks = @()         # Full TodoTracker task model with subtasks, includes command snippets
    TimeEntries = @()   # All time entries with manual and timer support
    ActiveTimers = @{}  # Currently running timers
    ArchivedTasks = @() # TodoTracker archive
    ExcelCopyJobs = @{} # Saved Excel copy configurations (NEW - ensure initialized)
    CurrentWeek = Get-Date -Hour 0 -Minute 0 -Second 0 # Default, can be changed
    Settings = Get-DefaultSettings # Call function to get complex default settings
}

function Get-DefaultSettings {
    # This function is from core-data-ps1 (11).txt and is comprehensive.
    # Ensure ExcelCopyJobs settings are included if any are specific to them.
    return @{
        # Time Tracker Settings
        DefaultRate = 100
        Currency = "USD"
        HoursPerDay = 8
        DaysPerWeek = 5
        TimeTrackerTemplates = @{
            "ADMIN" = @{ Id1 = "100"; Id2 = "ADM"; Name = "Administrative Tasks"; Client = "Internal"; Department = "Operations"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0; Rate = 0; Notes = "General administrative tasks" }
            "MEETING" = @{ Id1 = "101"; Id2 = "MTG"; Name = "Meetings & Calls"; Client = "Internal"; Department = "Various"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0; Rate = 0; Notes = "Team meetings and calls" }
            "TRAINING" = @{ Id1 = "102"; Id2 = "TRN"; Name = "Training & Learning"; Client = "Internal"; Department = "HR"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0; Rate = 0; Notes = "Professional development" }
            "BREAK" = @{ Id1 = "103"; Id2 = "BRK"; Name = "Breaks & Personal"; Client = "Internal"; Department = "Personal"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0; Rate = 0; Notes = "Breaks and personal time" }
        }
        # Todo Tracker Settings
        DefaultPriority = "Medium"
        DefaultCategory = "General"
        ShowCompletedDays = 7
        EnableTimeTracking = $true # For linking tasks to time entries
        AutoArchiveDays = 30
        # Command Snippets Settings (from core-data-ps1 (11).txt)
        CommandSnippets = @{
            EnableHotkeys = $true
            AutoCopyToClipboard = $true
            ShowInTaskList = $false # Default to false, commands are usually separate
            DefaultCategory = "Commands"
            RecentLimit = 10
        }
        # Excel Integration Settings
        ExcelFormConfig = @{ # From core-data-ps1 (11).txt
            WorksheetName = "Project Info"
            StandardFields = @{
                "Id1" = @{ LabelCell = "A5"; ValueCell = "B5"; Label = "Project ID"; Field = "Id1" }
                "Id2" = @{ LabelCell = "A6"; ValueCell = "B6"; Label = "Task Code"; Field = "Id2" }
                "Name" = @{ LabelCell = "A7"; ValueCell = "B7"; Label = "Project Name"; Field = "Name" }
                "FullName" = @{ LabelCell = "A8"; ValueCell = "B8"; Label = "Full Description"; Field = "FullName" }
                "AssignedDate" = @{ LabelCell = "A9"; ValueCell = "B9"; Label = "Start Date"; Field = "AssignedDate" }
                "DueDate" = @{ LabelCell = "A10"; ValueCell = "B10"; Label = "End Date"; Field = "DueDate" }
                "Manager" = @{ LabelCell = "A11"; ValueCell = "B11"; Label = "Project Manager"; Field = "Manager" }
                "Budget" = @{ LabelCell = "A12"; ValueCell = "B12"; Label = "Budget"; Field = "Budget" }
                "Status" = @{ LabelCell = "A13"; ValueCell = "B13"; Label = "Status"; Field = "Status" }
                "Priority" = @{ LabelCell = "A14"; ValueCell = "B14"; Label = "Priority"; Field = "Priority" }
                "Department" = @{ LabelCell = "A15"; ValueCell = "B15"; Label = "Department"; Field = "Department" }
                "Client" = @{ LabelCell = "A16"; ValueCell = "B16"; Label = "Client"; Field = "Client" }
                "BillingType" = @{ LabelCell = "A17"; ValueCell = "B17"; Label = "Billing Type"; Field = "BillingType" }
                "Rate" = @{ LabelCell = "A18"; ValueCell = "B18"; Label = "Hourly Rate"; Field = "Rate" }
            }
        }
        # Excel Copy Job Settings (NEW, if any specific defaults are needed)
        ExcelCopyJobOptions = @{
            DefaultMakeExcelVisible = $false
            DefaultOpenDestinationAfterCompletion = $false
        }
        # UI Theme (Legacy ConsoleColor names, will be processed by theme.ps1)
        Theme = @{ 
            Header = "Cyan"; Success = "Green"; Warning = "Yellow"; Error = "Red"; 
            Info = "Blue"; Accent = "Magenta"; Subtle = "DarkGray"
        }
        # Quick Action Tip
        QuickActionTipShown = $false # For first-run tip
    }
}

#endregion

#region Project Management (from core-data-ps1 (11).txt - largely complete)

function Get-ProjectOrTemplate {
    param([string]$Key)
    
    if ([string]::IsNullOrWhiteSpace($Key)) { return $null }

    if ($script:Data.Projects.ContainsKey($Key)) {
        return $script:Data.Projects[$Key]
    } elseif ($script:Data.Settings.TimeTrackerTemplates.ContainsKey($Key.ToUpper())) { # Templates often UPPERCASE
        return $script:Data.Settings.TimeTrackerTemplates[$Key.ToUpper()]
    }
    
    return $null
}

function Add-Project {
    Write-Header "Add New Project" # Uses theme.ps1
    
    $key = Read-Host "Project Key (short identifier, e.g., PROJ123)"
    if ([string]::IsNullOrWhiteSpace($key)) { Write-Error "Project key cannot be empty."; return }
    if ($script:Data.Projects.ContainsKey($key) -or $script:Data.Settings.TimeTrackerTemplates.ContainsKey($key.ToUpper())) {
        Write-Error "Project key '$key' already exists."
        return
    }
    
    Write-Host "`nBasic Information:" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    $name = Read-Host "Project Name"
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Error "Project name cannot be empty."; return }
    $id1 = Read-Host "ID1 (e.g., external system ID, optional)"
    $id2 = Read-Host "ID2 (max 9 chars, for timesheets, optional)"
    
    Write-Host "`nClient & Department:" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    $client = Read-Host "Client Name"
    $department = Read-Host "Department (optional)"
    
    Write-Host "`nBilling Information:" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host "Billing Type: [B]illable, [N]on-Billable, [F]ixed Price (default: Non-Billable)"
    $billingChoice = Read-Host "Choice (B/N/F)"
    $billingType = switch ($billingChoice.ToUpper()) {
        "B" { "Billable" }
        "F" { "Fixed Price" }
        default { "Non-Billable" }
    }
    
    $rate = 0.0
    $budget = 0.0
    
    if ($billingType -ne "Non-Billable") {
        $rateInput = Read-Host "Hourly Rate (default: $($script:Data.Settings.DefaultRate))"
        if (-not [string]::IsNullOrWhiteSpace($rateInput)) {
            if ($rateInput -match '^\d+(\.\d+)?$') { $rate = [double]$rateInput } 
            else { Write-Warning "Invalid rate format, using default."; $rate = $script:Data.Settings.DefaultRate }
        } else {
            $rate = $script:Data.Settings.DefaultRate
        }
        
        $budgetInput = Read-Host "Budget Hours (0 for unlimited, optional)"
        if (-not [string]::IsNullOrWhiteSpace($budgetInput)) {
            if ($budgetInput -match '^\d+(\.\d+)?$') { $budget = [double]$budgetInput }
            else { Write-Warning "Invalid budget format, setting to 0." }
        }
    }
    
    Write-Host "`nProject Status:" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host "[A]ctive, [O]n Hold, [C]ompleted (default: Active)"
    $statusChoice = Read-Host "Status (A/O/C)"
    $status = switch ($statusChoice.ToUpper()) {
        "O" { "On Hold" }
        "C" { "Completed" }
        default { "Active" }
    }
    
    $notes = Read-Host "`nProject Notes (optional)"
    
    $script:Data.Projects[$key] = @{
        Name = $name; Id1 = $id1; Id2 = $id2; Client = $client; Department = $department
        BillingType = $billingType; Rate = $rate; Budget = $budget; Status = $status; Notes = $notes
        StartDate = (Get-Date).ToString("yyyy-MM-dd"); CreatedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        TotalHours = 0.0; TotalBilled = 0.0; CompletedTasks = 0; ActiveTasks = 0 # Initial stats
        Manager = ""; Priority = "Medium"; DueDate = $null # Additional fields from model
    }
    
    Save-UnifiedData # helper.ps1
    Write-Success "Project added: $key - $name"
}

function Edit-Project {
    # Show-ProjectsAndTemplates is a UI function, should be called from menu before this
    $projectKey = Read-Host "Enter project key to edit (list with 'Show-ProjectsAndTemplates')"
     if ([string]::IsNullOrWhiteSpace($projectKey)) { Write-Error "Project key cannot be empty."; return }
    
    if (-not $script:Data.Projects.ContainsKey($projectKey)) {
        Write-Error "Project '$projectKey' not found or is a template (templates not editable here)."
        return
    }
    
    $project = $script:Data.Projects[$projectKey]
    
    Write-Header "Edit Project: $projectKey - $($project.Name)"
    Write-Host "Leave field empty to keep current value." -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    
    $fieldsToEdit = @(
        @{ Name="Name"; Current=$project.Name; Prompt="New Name" }
        @{ Name="Client"; Current=$project.Client; Prompt="New Client" }
        @{ Name="Department"; Current=$project.Department; Prompt="New Department" }
        @{ Name="Status"; Current=$project.Status; Prompt="New Status ([A]ctive, [O]n Hold, [C]ompleted)"; Type="Status" }
        @{ Name="BillingType"; Current=$project.BillingType; Prompt="New Billing Type ([B]illable, [N]on-Billable, [F]ixed Price)"; Type="Billing"}
        @{ Name="Rate"; Current=$project.Rate; Prompt="New Rate (if billable)"; Condition={ $project.BillingType -ne "Non-Billable" }; Type="Double"}
        @{ Name="Budget"; Current=$project.Budget; Prompt="New Budget Hours (if billable)"; Condition={ $project.BillingType -ne "Non-Billable" }; Type="Double"}
        @{ Name="Notes"; Current=$project.Notes; Prompt="New Notes (type 'CLEAR' to empty)" }
        @{ Name="Id1"; Current=$project.Id1; Prompt="New ID1" }
        @{ Name="Id2"; Current=$project.Id2; Prompt="New ID2 (max 9 chars)" }

    )

    $updated = $false
    foreach($field in $fieldsToEdit) {
        if ($field.ContainsKey("Condition") -and -not (& $field.Condition)) { continue } # Skip if condition not met

        Write-Host "`n$($field.Name) (Current: $($field.Current))" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")
        $newValue = Read-Host $field.Prompt
        
        if (-not [string]::IsNullOrEmpty($newValue)) {
            if ($field.Name -eq "Notes" -and $newValue.ToUpper() -eq "CLEAR") {
                $project[$field.Name] = ""
                $updated = $true
            } elseif ($field.Type -eq "Status") {
                $newStatusVal = switch ($newValue.ToUpper()) { "A"{"Active"} "O"{"On Hold"} "C"{"Completed"} default {$null} }
                if ($newStatusVal) { $project.Status = $newStatusVal; $updated = $true } 
                else { Write-Warning "Invalid status. Kept: $($project.Status)"}
            } elseif ($field.Type -eq "Billing") {
                $newBillingVal = switch ($newValue.ToUpper()) { "B"{"Billable"} "N"{"Non-Billable"} "F"{"Fixed Price"} default {$null} }
                if ($newBillingVal) { $project.BillingType = $newBillingVal; $updated = $true }
                else { Write-Warning "Invalid billing type. Kept: $($project.BillingType)"}
                 # If billing type changed to Non-Billable, reset rate/budget potentially
                if ($project.BillingType -eq "Non-Billable") { $project.Rate = 0; $project.Budget = 0 }
            } elseif ($field.Type -eq "Double") {
                if ($newValue -match '^\d+(\.\d+)?$') { $project[$field.Name] = [double]$newValue; $updated = $true }
                else { Write-Warning "Invalid number format for $($field.Name). Kept: $($project[$field.Name])" }
            } else {
                $project[$field.Name] = $newValue
                $updated = $true
            }
        }
    }
    
    if ($updated) {
        Save-UnifiedData
        Write-Success "Project '$projectKey' updated!"
    } else {
        Write-Info "No changes made to project '$projectKey'."
    }
}

function Update-ProjectStatistics {
    param([string]$ProjectKey)
    
    if (-not $ProjectKey -or -not $script:Data.Projects.ContainsKey($ProjectKey)) { return }
    $project = $script:Data.Projects[$ProjectKey]
    
    $projectEntries = $script:Data.TimeEntries | Where-Object { $_.ProjectKey -eq $ProjectKey }
    $project.TotalHours = [Math]::Round(($projectEntries | Measure-Object -Property Hours -Sum).Sum, 2)
    
    # Excluding command snippets from project task counts
    $projectTasks = $script:Data.Tasks | Where-Object { $_.ProjectKey -eq $ProjectKey -and $_.IsCommand -ne $true }
    $project.CompletedTasks = ($projectTasks | Where-Object { $_.Completed }).Count
    $project.ActiveTasks = ($projectTasks | Where-Object { -not $_.Completed }).Count
}

function Export-Projects { # From core-data-ps1 (11).txt
    Write-Header "Export Projects"
    
    $exportData = @()
    foreach ($proj in $script:Data.Projects.GetEnumerator()) {
        $exportData += [PSCustomObject]@{
            Key = $proj.Key; Name = $proj.Value.Name; Id1 = $proj.Value.Id1; Id2 = $proj.Value.Id2
            Client = $proj.Value.Client; Department = $proj.Value.Department; Status = $proj.Value.Status
            BillingType = $proj.Value.BillingType; Rate = $proj.Value.Rate; Budget = $proj.Value.Budget
            TotalHours = $proj.Value.TotalHours; ActiveTasks = $proj.Value.ActiveTasks; CompletedTasks = $proj.Value.CompletedTasks
        }
    }
    
    if ($exportData.Count -eq 0) { Write-Warning "No projects to export."; return }

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $exportFile = Join-Path ([Environment]::GetFolderPath("Desktop")) "Projects_Export_$timestamp.csv"
    
    try {
        $exportData | Export-Csv -Path $exportFile -NoTypeInformation -UseCulture
        Write-Success "Projects exported to: $exportFile"
        if (Test-Path $exportFile) { Start-Process $exportFile }
    } catch {
        Write-Error "Failed to export projects: $_"
    }
}

function Batch-ImportProjects { # Stub from core-data-ps1 (11).txt
    Write-Warning "Batch Import Projects: Feature not yet fully implemented."
    Write-Info "This feature would typically involve reading a CSV or Excel list of projects."
    # Placeholder:
    # 1. Ask for file path (CSV/Excel)
    # 2. Define expected column mapping (or use a configurable one)
    # 3. Loop through rows, create project objects (similar to Add-Project or Import-ProjectFromExcel)
    # 4. Handle errors, duplicates, provide summary.
}

#endregion

#region Command Snippets System (from core-data-ps1 (11).txt - Requirement D)

function Add-CommandSnippet {
    Write-Header "Add Command Snippet"
    
    $name = Read-Host "Command name/description"
    if ([string]::IsNullOrEmpty($name)) { Write-Error "Command name cannot be empty!"; return }
    
    Write-Host "`nEnter command (press Enter on an empty line to finish multiline input):" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    $lines = @()
    while ($true) {
        $line = Read-Host "CmdLine>" # Prompt for multiline input
        if ([string]::IsNullOrEmpty($line) -and $lines.Count -gt 0 -and $lines[-1] -eq "") { # Requires two empty lines to finish
             $lines = $lines[0..($lines.Count-2)] # Remove the last empty line signal
             break 
        }
        if ([string]::IsNullOrEmpty($line) -and $lines.Count -eq 0) { # First line is empty
            Write-Warning "Command content cannot start with an empty line if it's the only line. Try again or type something."
            continue
        }
        $lines += $line
        if ($lines.Count -eq 1 -and -not [string]::IsNullOrEmpty($line) -and ($Host.UI.ReadLine() -eq "")) { # Single line input followed by enter
             # This heuristic for single line is tricky with Read-Host.
             # Best to instruct user: "Press Enter on an empty line to finish" (meaning one empty line ends it)
        }
    }
    # Simplified: one empty line to finish
    # $lines = @()
    # $currentLine = Read-Host "CmdLine>"
    # while (-not [string]::IsNullOrEmpty($currentLine)) {
    #    $lines += $currentLine
    #    $currentLine = Read-Host "CmdLine>"
    # }

    $command = $lines -join [Environment]::NewLine
    if ([string]::IsNullOrWhiteSpace($command)) { Write-Error "Command content cannot be empty!"; return }
    
    $existingCategories = $script:Data.Tasks | 
        Where-Object { $_.IsCommand -eq $true } | 
        Select-Object -ExpandProperty Category -Unique | 
        Where-Object { -not [String]::IsNullOrWhiteSpace($_) } | Sort-Object
    
    if ($existingCategories.Count -gt 0) {
        Write-Host "`nExisting categories: $($existingCategories -join ', ')" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")
    }
    $category = Read-Host "Category (default: $($script:Data.Settings.CommandSnippets.DefaultCategory))"
    if ([string]::IsNullOrEmpty($category)) { $category = $script:Data.Settings.CommandSnippets.DefaultCategory }
    
    Write-Host "`nTags (comma-separated, optional):" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    $tagsInput = Read-Host "Tags"
    $tags = if ($tagsInput) { $tagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ } } else { @() }
    
    $hotkey = ""
    if ($script:Data.Settings.CommandSnippets.EnableHotkeys) {
        Write-Host "`nAssign hotkey (e.g., 'Ctrl+Shift+S', informational only, no OS hook):" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
        $hotkey = Read-Host "Hotkey"
    }
    
    $snippet = @{
        Id = New-TodoId # helper.ps1
        Description = $name; Priority = "Low"; Category = $category; ProjectKey = $null
        StartDate = $null; DueDate = $null; Tags = $tags; Progress = 0; Completed = $false # Task fields
        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null
        EstimatedTime = 0; TimeSpent = 0; Subtasks = @(); Notes = $command # Notes holds the command
        LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
        IsCommand = $true; Hotkey = $hotkey; LastUsed = $null; UseCount = 0
    }
    
    $script:Data.Tasks += $snippet
    Save-UnifiedData
    
    Write-Success "Command snippet added: $name"
    if ($script:Data.Settings.CommandSnippets.AutoCopyToClipboard) {
        if (Get-Command Copy-ToClipboard -ErrorAction SilentlyContinue) { # Copy-ToClipboard is in helper.ps1
            if (Copy-ToClipboard $command) { Write-Info "Command copied to clipboard!" }
        }
    }
}

function Get-CommandSnippet { # Renamed from Search-CommandSnippets to be more generic getter
    param(
        [string]$Id,
        [string]$SearchTerm,
        [string]$Category,
        [string[]]$Tags,
        [string]$Hotkey
    )
    
    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }
    
    if ($Id) {
        # Allow partial ID match (e.g., first 6 chars)
        $snippets = $snippets | Where-Object { $_.Id.StartsWith($Id) }
    }
    if ($SearchTerm) {
        $snippets = $snippets | Where-Object { 
            $_.Description -like "*$SearchTerm*" -or 
            $_.Notes -like "*$SearchTerm*" -or
            ($_.Tags -join " ") -like "*$SearchTerm*" -or # Search in tags
            $_.Category -like "*$SearchTerm*" # Search in category
        }
    }
    if ($Category) {
        $snippets = $snippets | Where-Object { $_.Category -eq $Category }
    }
    if ($Tags -and $Tags.Count -gt 0) {
        $snippets = $snippets | Where-Object {
            $sTags = $_.Tags
            ($Tags | ForEach-Object { $tagToFind = $_; $sTags -contains $tagToFind }).Contains($true) # Any tag matches
        }
    }
    if ($Hotkey) {
        $snippets = $snippets | Where-Object { $_.Hotkey -eq $Hotkey }
    }
    
    return $snippets | Sort-Object UseCount -Descending, Description
}

function Browse-CommandSnippets { # UI Function that uses Get-CommandSnippet
    Write-Header "Browse/Search Command Snippets"
    $searchTerm = Read-Host "Search term (text, #category, @tag, or leave empty for all)"

    $parsedCategory = $null
    $parsedTags = @()

    if ($searchTerm -match '#(\S+)') { $parsedCategory = $Matches[1]; $searchTerm = $searchTerm -replace "#$($Matches[1])" }
    $searchTerm -match '@(\S+)' | Out-Null # To populate $Matches
    if ($Matches[1]) { $parsedTags = $Matches[1] -split ','; $searchTerm = $searchTerm -replace "@$($Matches[1])" }
    $searchTerm = $searchTerm.Trim()

    $snippets = Get-CommandSnippet -SearchTerm $searchTerm -Category $parsedCategory -Tags $parsedTags
    
    if ($snippets.Count -eq 0) { Write-Host "No snippets found matching criteria." -ForegroundColor Gray; return }

    $tableData = $snippets | ForEach-Object -Begin {$idx=0} -Process {
        $idx++
        [PSCustomObject]@{
            Num = $idx
            ID = $_.Id.Substring(0, 6)
            Name = if($_.Description.Length -gt 30) { $_.Description.Substring(0,27)+"..."} else {$_.Description}
            Category = $_.Category
            Tags = ($_.Tags -join ", ")
            Used = $_.UseCount
            Hotkey = if ($_.Hotkey) { $_.Hotkey } else { "-" }
        }
    }
    
    $columns = @(
        @{Name="Num"; Title="#"; Width=3}
        @{Name="ID"; Title="ID"; Width=8}
        @{Name="Name"; Title="Name"; Width=30}
        @{Name="Category"; Title="Category"; Width=15}
        @{Name="Tags"; Title="Tags"; Width=20; Wrap=$true}
        @{Name="Used"; Title="Used"; Width=6; Align="Right"}
        @{Name="Hotkey"; Title="Hotkey"; Width=10}
    )
    Format-TableUnicode -Data $tableData -Columns $columns -Title "Command Snippets Found ($($snippets.Count))"

    Write-Host "`nEnter snippet # or ID to use/manage, or press Enter to cancel."
    $selectedKey = Read-Host "Selection"
    
    if ([stringIsNullOrWhiteSpace]($selectedKey)) { return }

    $selectedSnippet = $null
    if ($selectedKey -match '^\d+$') { # Selected by number
        $num = [int]$selectedKey
        if ($num -gt 0 -and $num -le $tableData.Count) {
            $selectedSnippetId = $tableData[$num-1].ID # Get ID from table
            $selectedSnippet = Get-CommandSnippet -Id $selectedSnippetId | Select-Object -First 1
        }
    } else { # Selected by ID (partial or full)
         $selectedSnippet = Get-CommandSnippet -Id $selectedKey | Select-Object -First 1
    }

    if ($selectedSnippet) {
        Execute-CommandSnippet -SnippetObject $selectedSnippet # Pass the object to avoid re-fetch
    } else {
        Write-Error "Snippet not found by '$selectedKey'."
    }
}

function Execute-CommandSnippet { # Can accept ID or the snippet object itself
    param(
        [string]$Id,
        [PSCustomObject]$SnippetObject
    )
    
    $snippet = $SnippetObject
    if (-not $snippet -and $Id) {
        $snippet = Get-CommandSnippet -Id $Id | Select-Object -First 1
    }
    
    if (-not $snippet) { Write-Error "Snippet not found!"; return }
    
    Write-Host "`nCommand: $($snippet.Description)" -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
    Write-Host "Category: $($snippet.Category)" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    if ($snippet.Tags.Count -gt 0) { Write-Host "Tags: $($snippet.Tags -join ', ')" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG") }
    
    Write-Host "`nCommand content:" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host $snippet.Notes -ForegroundColor (Get-ThemeProperty "Palette.PrimaryFG") # White
    
    # Update usage stats directly on the object in $script:Data.Tasks
    $taskRef = $script:Data.Tasks | Where-Object {$_.Id -eq $snippet.Id} | Select-Object -First 1
    if ($taskRef) {
        $taskRef.LastUsed = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        $taskRef.UseCount = [int]$taskRef.UseCount + 1
        Save-UnifiedData
    }
    
    Write-Host "`n[C]opy to clipboard, [E]xecute (PowerShell - BE CAREFUL!), [M]odify, [D]elete, or [Enter] to cancel"
    $action = Read-Host "Action"
    
    switch ($action.ToUpper()) {
        "C" { if (Copy-ToClipboard $snippet.Notes) { Write-Success "Command copied!" } }
        "E" {
            Write-Warning "ARE YOU SURE you want to execute this command in the current PowerShell session?"
            Write-Warning $snippet.Notes
            $confirm = Read-Host "Type 'YES_EXECUTE' to confirm"
            if ($confirm -eq 'YES_EXECUTE') {
                try {
                    Invoke-Expression $snippet.Notes
                    Write-Success "Command executed!"
                } catch { Write-Error "Execution failed: $_" }
            } else { Write-Info "Execution cancelled."}
        }
        "M" { Edit-Task -TaskId $snippet.Id } # Use Edit-Task for snippets too
        "D" { Remove-CommandSnippet -Id $snippet.Id -Confirm:$false } # Confirm inside Remove
        default { Write-Info "No action taken." }
    }
}

function Remove-CommandSnippet {
    param(
        [string]$Id,
        [switch]$Confirm = $true # Allow skipping confirm if already done
    )
    
    if (-not $Id) {
        # Call browse to let user pick
        Browse-CommandSnippets 
        # User might select and execute from Browse, or it might return.
        # If Remove-CommandSnippet is called again from Execute-CommandSnippet, ID will be set.
        return 
    }
    
    $snippet = Get-CommandSnippet -Id $Id | Select-Object -First 1
    if (-not $snippet) { Write-Error "Snippet not found by ID '$Id'!"; return }
    
    if ($Confirm) {
        Write-Warning "Delete snippet: '$($snippet.Description)'?"
        $confirmation = Read-Host "Type 'yes' to confirm"
    } else {
        $confirmation = 'yes' # Skipped confirmation
    }
    
    if ($confirmation -eq 'yes') {
        $originalTaskCount = $script:Data.Tasks.Count
        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -ne $snippet.Id }
        if ($script:Data.Tasks.Count -lt $originalTaskCount) {
            Save-UnifiedData
            Write-Success "Snippet '$($snippet.Description)' deleted!"
        } else {
            Write-Error "Failed to delete snippet (was it already removed?)."
        }
    } else {
        Write-Info "Deletion cancelled."
    }
}

function Manage-CommandSnippets { # Main menu for snippets
    while ($true) {
        Write-Header "Command Snippets Management"
        
        $snippetCount = ($script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }).Count
        Write-Host "Total snippets: $snippetCount" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
        
        $recent = Get-RecentCommandSnippets -Count 3
        if ($recent.Count -gt 0) {
            Write-Host "`nRecent snippets:" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
            foreach ($s in $recent) {
                $hotkeyInfo = if ($s.Hotkey) { " ($($s.Hotkey))" } else { "" }
                Write-Host "  [$($s.Id.Substring(0,6))] $($s.Description)$hotkeyInfo - Used: $($s.UseCount)"
            }
        }
        
        $options = @(
            @{ Key="A"; Label="Add new snippet"; Action={ Add-CommandSnippet } }
            @{ Key="S"; Label="Search/Browse snippets"; Action={ Browse-CommandSnippets } }
            @{ Key="X"; Label="Execute by ID"; Action={ $id = Read-Host "Snippet ID to execute"; Execute-CommandSnippet -Id $id } }
            @{ Key="E"; Label="Edit snippet by ID"; Action={ $id = Read-Host "Snippet ID to edit"; Edit-Task -TaskId $id } } # Edit-Task for snippets
            @{ Key="D"; Label="Delete snippet by ID"; Action={ $id = Read-Host "Snippet ID to delete"; Remove-CommandSnippet -Id $id } }
            @{ Key="C"; Label="View Categories"; Action={ Show-SnippetCategories } }
            @{ Key="H"; Label="View Hotkeys"; Action={ Show-SnippetHotkeys } }
            @{ Key="O"; Label="Options/Settings"; Action={ Edit-CommandSnippetSettings } }
            @{ Key="B"; Label="Back to Main Menu"; Action={ return } }
        )
        
        Write-Host "`nOptions:"
        foreach($opt in $options) { Write-Host "  [$($opt.Key)] $($opt.Label)" }
        
        $choice = Read-Host "`nChoice"
        $selectedOption = $options | Where-Object { $_.Key -eq $choice.ToUpper() } | Select-Object -First 1
        
        if ($selectedOption) {
            & $selectedOption.Action
            if ($selectedOption.Key -ne "B") {
                 Write-Host "`nPress Enter to continue..." ; Read-Host | Out-Null
            }
        } elseif (-not [string]::IsNullOrWhiteSpace($choice)) {
            Write-Warning "Invalid choice."
            Start-Sleep -Seconds 1
        }
        if ($choice.ToUpper() -eq "B") { break } # Exit loop for 'Back'
    }
}

function Get-RecentCommandSnippets { # Helper for Manage-CommandSnippets
    param([int]$Count = 10)
    
    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true -and $_.LastUsed }
    return $snippets | Sort-Object @{Expression={[datetime]$_.LastUsed}; Descending=$true}, UseCount -Descending | Select-Object -First $Count
}

function Show-SnippetCategories { # UI for snippet categories
    Write-Header "Snippet Categories"
    $categories = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true } | Group-Object Category | Sort-Object Count -Descending
    if ($categories.Count -eq 0) { Write-Host "No categories found." -ForegroundColor Gray; return }
    
    $catData = $categories | ForEach-Object {
        [PSCustomObject]@{ Category = if ([stringIsNullOrWhiteSpace]($_.Name)) {"(Uncategorized)"} else {$_.Name} ; Count = $_.Count }
    }
    Format-TableUnicode -Data $catData -Columns @(
        @{Name="Category"; Title="Category"; Width=30},
        @{Name="Count"; Title="Snippets"; Width=10; Align="Right"}
    )
}

function Show-SnippetHotkeys { # UI for snippet hotkeys
    Write-Header "Assigned Snippet Hotkeys"
    $hotkeyed = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true -and $_.Hotkey } | Sort-Object Hotkey
    if ($hotkeyed.Count -eq 0) { Write-Host "No hotkeys assigned." -ForegroundColor Gray; return }

    $hotkeyData = $hotkeyed | ForEach-Object {
        [PSCustomObject]@{ Hotkey = $_.Hotkey; Description = $_.Description; ID=$_.Id.Substring(0,6) }
    }
     Format-TableUnicode -Data $hotkeyData -Columns @(
        @{Name="Hotkey"; Title="Hotkey"; Width=20},
        @{Name="Description"; Title="Command"; Width=40},
        @{Name="ID"; Title="ID"; Width=8}
    )
    Write-Warning "`nNote: Hotkey functionality for OS-wide use requires an external keyboard hooking tool."
}

function Edit-CommandSnippetSettings { # Settings for snippets
    Write-Header "Command Snippet Settings"
    $settings = $script:Data.Settings.CommandSnippets
    
    $currentSettings = @(
        @{ Prop="EnableHotkeys"; Current=$settings.EnableHotkeys; Prompt="Enable Hotkeys (informational only)? (Y/N)"}
        @{ Prop="AutoCopyToClipboard"; Current=$settings.AutoCopyToClipboard; Prompt="Auto-copy new snippets to clipboard? (Y/N)"}
        @{ Prop="ShowInTaskList"; Current=$settings.ShowInTaskList; Prompt="Show command snippets in main task list? (Y/N)"}
        @{ Prop="DefaultCategory"; Current=$settings.DefaultCategory; Prompt="New default category for snippets"}
        @{ Prop="RecentLimit"; Current=$settings.RecentLimit; Prompt="Number of recent snippets to show (e.g., 5-10)"}
    )

    foreach ($item in $currentSettings) {
        Write-Host "`n$($item.Prop) (Current: $($item.Current))" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")
        $input = Read-Host $item.Prompt
        if (-not [string]::IsNullOrWhiteSpace($input)) {
            if ($input -match '^(Y|N)$') { # Boolean Y/N
                $settings[$item.Prop] = ($input -eq 'Y')
            } elseif ($item.Prop -eq "RecentLimit" -and $input -match '^\d+$') { # Integer
                $settings[$item.Prop] = [int]$input
            } elseif ($item.Prop -eq "DefaultCategory") { # String
                $settings[$item.Prop] = $input
            } else {
                Write-Warning "Invalid input for $($item.Prop). Keeping current."
            }
        }
    }
    Save-UnifiedData
    Write-Success "Command Snippet settings updated!"
}

#endregion

#region Task Management Core Logic (Migrated from Pmc Mod Base.txt, adapted)

function Add-TodoTask {
    Write-Header "Add New Task" # Uses theme.ps1
   
    $description = Read-Host "`nTask description"
    if ([string]::IsNullOrEmpty($description)) { Write-Error "Task description cannot be empty!"; return }
   
    Write-Host "`nPriority: [C]ritical, [H]igh, [M]edium, [L]ow (default: $($script:Data.Settings.DefaultPriority))"
    $priorityInput = Read-Host "Priority"
    $priority = switch ($priorityInput.ToUpper()) {
        "C" { "Critical" } "H" { "High" } "L" { "Low" } "M" { "Medium" }
        default { $script:Data.Settings.DefaultPriority }
    }
   
    $existingCategories = $script:Data.Tasks | Where-Object { -not $_.IsCommand -and $_.Category } | Select-Object -ExpandProperty Category -Unique | Sort-Object
    if ($existingCategories) { Write-Host "`nExisting categories: $($existingCategories -join ', ')" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG") }
    $category = Read-Host "Category (default: $($script:Data.Settings.DefaultCategory))"
    if ([string]::IsNullOrEmpty($category)) { $category = $script:Data.Settings.DefaultCategory }
   
    Write-Host "`nLink to project? (Y/N)"
    $projectKey = $null
    if ((Read-Host).ToUpper() -eq 'Y') {
        Show-ProjectsAndTemplates -Simple # UI Function
        $projectKeyInput = Read-Host "`nProject key"
        if ($projectKeyInput -and (Get-ProjectOrTemplate $projectKeyInput)) { $projectKey = $projectKeyInput }
        else { Write-Warning "Project not found or invalid. Task will be unassigned." }
    }
   
    # Dates (simplified input from Pmc Mod Base)
    $startDate = $null; $dueDate = $null
    $startDateStr = Read-Host "`nStart date (YYYY-MM-DD, 'today', '+Xdays', optional)"
    if ($startDateStr) { try { $startDate = Parse-SmartDate $startDateStr } catch { Write-Warning "Invalid start date. Not set."} }
    
    $dueDateStr = Read-Host "`nDue date (YYYY-MM-DD, 'today', '+Xdays', optional)"
    if ($dueDateStr) { try { $dueDate = Parse-SmartDate $dueDateStr } catch { Write-Warning "Invalid due date. Not set."} }

    $tagsInput = Read-Host "`nTags (comma-separated, optional)"
    $tags = if ($tagsInput) { $tagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ } } else { @() }
   
    $estTimeInput = Read-Host "`nEstimated time in hours (optional)"
    $estimatedTime = if ($estTimeInput -match '^\d+(\.\d+)?$') { [double]$estTimeInput } else { 0 }
   
    $subtasks = @()
    Write-Host "`nAdd subtasks? (Y/N)"
    if ((Read-Host).ToUpper() -eq 'Y') {
        Write-Host "Enter subtasks (empty line to finish):"
        while ($true) {
            $subDesc = Read-Host "  Subtask"
            if ([string]::IsNullOrEmpty($subDesc)) { break }
            $subtasks += @{ Description = $subDesc; Completed = $false; CompletedDate = $null }
        }
    }
   
    $newTask = @{
        Id = New-TodoId; Description = $description; Priority = $priority; Category = $category; ProjectKey = $projectKey
        StartDate = if($startDate) {$startDate.ToString("yyyy-MM-dd")} else {$null}
        DueDate = if($dueDate) {$dueDate.ToString("yyyy-MM-dd")} else {$null}
        Tags = $tags; Progress = 0; Completed = $false
        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null
        EstimatedTime = $estimatedTime; TimeSpent = 0; Subtasks = $subtasks; Notes = ""
        LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); IsCommand = $false
    }
   
    $script:Data.Tasks += $newTask
    if ($projectKey) { Update-ProjectStatistics -ProjectKey $projectKey }
    Save-UnifiedData
    Write-Success "Task '$($newTask.Description)' added successfully! ID: $($newTask.Id)"
}

function Quick-AddTask { # Migrated from Pmc Mod Base, refined
    param([string]$Input)
   
    if (-not $Input) { $Input = Read-Host "Quick add task details" }
   
    $description = $Input
    # Defaults
    $category = $script:Data.Settings.DefaultCategory
    $tags = @()
    $priority = $script:Data.Settings.DefaultPriority
    $dueDate = $null; $startDate = $null; $projectKey = $null; $estimatedTime = 0

    # Regex to extract parts, improved for robustness
    if ($description -match '#(\S+)') { $category = $Matches[1]; $description = $description -replace ('#' + [regex]::Escape($Matches[1])), '' }
    if ($description -match '@((?:\w|\-|,)+)') { $tags = ($Matches[1] -split ',' | ForEach-Object { $_.Trim() }); $description = $description -replace ('@' + [regex]::Escape($Matches[1])), '' }
    if ($description -match '!(critical|high|medium|low|c|h|m|l)\b' ) { # \b for word boundary
        $priority = switch ($Matches[1].ToLower()) {
            "c" "critical" { "Critical" } "h" "high" { "High" } "l" "low" { "Low" } default { "Medium" }
        }
        $description = $description -replace ('!' + [regex]::Escape($Matches[1])), ''
    }
    if ($description -match 'project:(\S+)') {
        $pk = $Matches[1]
        if (Get-ProjectOrTemplate $pk) { $projectKey = $pk } else { Write-Warning "Project '$pk' not found."}
        $description = $description -replace ('project:' + [regex]::Escape($pk)), ''
    }
    if ($description -match 'est:(\d+\.?\d*)') { $estimatedTime = [double]$Matches[1]; $description = $description -replace ('est:' + [regex]::Escape($Matches[1])), '' }
    if ($description -match 'due:(\S+)') {
        try { $dueDate = Parse-SmartDate $Matches[1] } catch { Write-Warning "Invalid due date '$($Matches[1])'."}
        $description = $description -replace ('due:' + [regex]::Escape($Matches[1])), ''
    }
     if ($description -match 'start:(\S+)') {
        try { $startDate = Parse-SmartDate $Matches[1] } catch { Write-Warning "Invalid start date '$($Matches[1])'."}
        $description = $description -replace ('start:' + [regex]::Escape($Matches[1])), ''
    }

    $description = $description.Trim() -replace '\s+', ' ' # Clean up description
    if ([string]::IsNullOrEmpty($description)) { Write-Error "Task description is empty after parsing!"; return }

    $newTask = @{
        Id = New-TodoId; Description = $description; Priority = $priority; Category = $category; ProjectKey = $projectKey
        StartDate = if($startDate) {$startDate.ToString("yyyy-MM-dd")} else {$null}
        DueDate = if($dueDate) {$dueDate.ToString("yyyy-MM-dd")} else {$null}
        Tags = $tags; Progress = 0; Completed = $false
        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null
        EstimatedTime = $estimatedTime; TimeSpent = 0; Subtasks = @(); Notes = ""; IsCommand = $false
        LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
    }
    $script:Data.Tasks += $newTask
    if ($projectKey) { Update-ProjectStatistics -ProjectKey $projectKey }
    Save-UnifiedData
    Write-Success "Quick task added: '$description'"
}

function Parse-SmartDate { # Helper for Add-Task, Quick-AddTask
    param([string]$DateInput)
    if ([string]::IsNullOrWhiteSpace($DateInput)) { return $null }
    $lowerDateInput = $DateInput.ToLower()
    switch -Regex ($lowerDateInput) {
        '^today$' { return [datetime]::Today.Date }
        '^tomorrow$' { return [datetime]::Today.AddDays(1).Date }
        '^yesterday$' { return [datetime]::Today.AddDays(-1).Date }
        '^\+(\d+)d(ays)?$' { return [datetime]::Today.AddDays([int]$Matches[1]).Date }
        '^\-(\d+)d(ays)?$' { return [datetime]::Today.AddDays(-[int]$Matches[1]).Date }
        '^(mon|tue|wed|thu|fri|sat|sun)(day)?$' {
            $dayMap = @{mon=1;tue=2;wed=3;thu=4;fri=5;sat=6;sun=0}
            return Get-NextWeekday $dayMap[$Matches[1]] # Get-NextWeekday is in helper.ps1
        }
        default { return [datetime]::Parse($DateInput).Date } # Default parsing
    }
    Throw "Could not parse date: $DateInput"
}

function Complete-Task {
    param([string]$TaskId)
    if (-not $TaskId) { Write-Error "Task ID required."; return } # Should be called after UI selection
    $task = $script:Data.Tasks | Where-Object { $_.Id.StartsWith($TaskId) -and $_.IsCommand -ne $true } | Select-Object -First 1
    if (-not $task) { Write-Error "Task '$TaskId' not found or is a command snippet."; return }
    if ($task.Completed) { Write-Info "Task '$($task.Description)' is already completed."; return }

    $uncompletedSubtasks = $task.Subtasks | Where-Object { -not $_.Completed }
    if ($uncompletedSubtasks.Count -gt 0) {
        Write-Warning "Task has $($uncompletedSubtasks.Count) uncompleted subtask(s). Complete anyway? (Y/N)"
        if ((Read-Host).ToUpper() -ne 'Y') { Write-Info "Completion cancelled."; return }
    }
    $task.Completed = $true; $task.Progress = 100
    $task.CompletedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
    $task.LastModified = $task.CompletedDate
    if ($task.ProjectKey) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }
    Save-UnifiedData
    Write-Success "Completed: $($task.Description)"
}

function Update-TaskProgress {
    param([string]$TaskId)
    if (-not $TaskId) { Write-Error "Task ID required."; return }
    $task = $script:Data.Tasks | Where-Object { $_.Id.StartsWith($TaskId) -and $_.IsCommand -ne $true } | Select-Object -First 1
    if (-not $task) { Write-Error "Task '$TaskId' not found or is a command snippet."; return }
    if ($task.Completed) { Write-Info "Task is already completed. Un-complete first to change progress."; return }

    Write-Host "`nTask: $($task.Description) (Current Progress: $($task.Progress)%)"
    Draw-ProgressBar -Percent $task.Progress # UI function

    $newProgressInput = Read-Host "New progress (0-100, or 'S' to sync from subtasks if any)"
    if ($newProgressInput.ToUpper() -eq 'S' -and $task.Subtasks.Count -gt 0) {
        $completedSubs = ($task.Subtasks | Where-Object { $_.Completed }).Count
        $task.Progress = [Math]::Round(($completedSubs / $task.Subtasks.Count) * 100, 0)
        Write-Info "Progress synced from subtasks to $($task.Progress)%."
    } elseif ($newProgressInput -match '^\d+$') {
        $newProgress = [int]$newProgressInput
        if ($newProgress -lt 0 -or $newProgress -gt 100) { Write-Error "Progress must be 0-100."; return }
        $task.Progress = $newProgress
    } else { Write-Warning "Invalid input. Progress not changed."; return }

    if ($task.Progress -eq 100) { $task.Completed = $true; $task.CompletedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss") }
    $task.LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
    Save-UnifiedData
    Write-Success "Progress updated for '$($task.Description)' to $($task.Progress)%."
}

function Edit-Task { # Also used for Command Snippets (IsCommand=true tasks)
    param([string]$TaskId)
    if (-not $TaskId) { Write-Error "Task ID required."; return }
    $task = $script:Data.Tasks | Where-Object { $_.Id.StartsWith($TaskId) } | Select-Object -First 1
    if (-not $task) { Write-Error "Task/Snippet '$TaskId' not found."; return }

    $headerText = if ($task.IsCommand) { "Edit Command Snippet" } else { "Edit Task" }
    Write-Header "$headerText: $($task.Description)"
    Write-Host "Leave field empty to keep current value." -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    # Common fields
    $task.Description = Read-Host "Description ($($task.Description))" | ForEach-Object { if (-not [string]::IsNullOrWhiteSpace($_)) { $_ } else { $task.Description } }
    $task.Category = Read-Host "Category ($($task.Category))" | ForEach-Object { if (-not [string]::IsNullOrWhiteSpace($_)) { $_ } else { $task.Category } }
    $newTags = Read-Host "Tags (comma-sep, current: $($task.Tags -join ', '))"
    if ($newTags -ne $null) { $task.Tags = if ([string]::IsNullOrWhiteSpace($newTags)) {@()} else {$newTags -split ',' | % {$_.Trim()} | ? {$_}} }

    if ($task.IsCommand) {
        $task.Notes = Read-Host "Command Content (current has $($task.Notes.Length) chars). Enter new or 'CLEAR'" | ForEach-Object {
            if ($_ -eq "CLEAR") { "" } elseif (-not [string]::IsNullOrEmpty($_)) { $_ } else { $task.Notes }
        }
        $task.Hotkey = Read-Host "Hotkey ($($task.Hotkey))" | ForEach-Object { if (-not [string]::IsNullOrEmpty($_)) { $_ } else { $task.Hotkey } }
    } else { # Task-specific fields
        $newPriorityStr = Read-Host "Priority ($($task.Priority)): [C]rit, [H]igh, [M]ed, [L]ow"
        if ($newPriorityStr) { $task.Priority = (switch ($newPriorityStr.ToUpper()) {"C"{"Critical"}"H"{"High"}"M"{"Medium"}"L"{"Low"} default {$task.Priority}}) }

        $currentProjName = if ($task.ProjectKey) { (Get-ProjectOrTemplate $task.ProjectKey).Name } else { "None" }
        $newProjKey = Read-Host "Project Key ($currentProjName). Enter key or 'CLEAR'"
        if ($newProjKey) {
            if ($newProjKey.ToUpper() -eq 'CLEAR') { $task.ProjectKey = $null }
            elseif (Get-ProjectOrTemplate $newProjKey) { $task.ProjectKey = $newProjKey }
            else { Write-Warning "Project '$newProjKey' not found. Kept current."}
        }
        
        $currentDueDate = if ($task.DueDate) { (Format-TodoDate $task.DueDate) } else {"None"}
        $newDueDateStr = Read-Host "Due Date ($currentDueDate). Enter date, 'CLEAR', or smart date"
        if ($newDueDateStr) {
            if ($newDueDateStr.ToUpper() -eq 'CLEAR') { $task.DueDate = $null }
            else { try { $task.DueDate = (Parse-SmartDate $newDueDateStr).ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid due date. Kept current."}}
        }
        # Similar for StartDate, EstimatedTime, Notes (for tasks)
        $currentNotes = if ([string]::IsNullOrWhiteSpace($task.Notes)) {"Empty"} else {"Has notes"}
        $newNotes = Read-Host "Notes ($currentNotes). Enter new notes or 'CLEAR'"
        if ($newNotes -ne $null) { $task.Notes = if ($newNotes.ToUpper() -eq 'CLEAR') {""} else {$newNotes} }
    }
    
    $task.LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
    if ($task.ProjectKey -and -not $task.IsCommand) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }
    Save-UnifiedData
    Write-Success "$headerText for '$($task.Description)' updated!"
}

function Manage-Subtasks {
    param([string]$TaskId)
    if (-not $TaskId) { Write-Error "Task ID required."; return }
    $task = $script:Data.Tasks | Where-Object { $_.Id.StartsWith($TaskId) -and $_.IsCommand -ne $true } | Select-Object -First 1
    if (-not $task) { Write-Error "Task '$TaskId' not found or is a command snippet."; return }

    while ($true) {
        Clear-Host; Write-Header "Manage Subtasks for: $($task.Description)"
        if ($task.Subtasks.Count -eq 0) { Write-Host "No subtasks." -ForegroundColor Gray } 
        else {
            for ($i=0; $i -lt $task.Subtasks.Count; $i++) {
                $sub = $task.Subtasks[$i]
                $statusIcon = if ($sub.Completed) {"✅"} else {"⬜"}
                Write-Host "  [$($i+1)] $statusIcon $($sub.Description)"
            }
        }
        Write-Host "`n[A]dd, [T]oggle Complete, [D]elete, [E]dit, [B]ack"
        $choice = Read-Host "Subtask Action"
        
        switch ($choice.ToUpper()) {
            "A" { 
                $desc = Read-Host "New subtask description"
                if ($desc) { $task.Subtasks += @{Description=$desc; Completed=$false}; $task.LastModified = Get-Date -F s; Write-Success "Added."}
            }
            "T" {
                $num = Read-Host "Number to toggle"
                if ($num -match '^\d+$' -and [int]$num -ge 1 -and [int]$num -le $task.Subtasks.Count) {
                    $idx = [int]$num - 1
                    $task.Subtasks[$idx].Completed = -not $task.Subtasks[$idx].Completed
                    $task.Subtasks[$idx].CompletedDate = if($task.Subtasks[$idx].Completed) {(Get-Date -F s)} else {$null}
                    $task.LastModified = Get-Date -F s
                    Write-Success "Toggled."
                } else { Write-Error "Invalid number."}
            }
            "D" {
                 $num = Read-Host "Number to delete"
                if ($num -match '^\d+$' -and [int]$num -ge 1 -and [int]$num -le $task.Subtasks.Count) {
                    $idx = [int]$num - 1
                    $task.Subtasks.RemoveAt($idx)
                    $task.LastModified = Get-Date -F s
                    Write-Success "Deleted."
                } else { Write-Error "Invalid number."}
            }
            "E" {
                $num = Read-Host "Number to edit"
                if ($num -match '^\d+$' -and [int]$num -ge 1 -and [int]$num -le $task.Subtasks.Count) {
                    $idx = [int]$num - 1
                    $newDesc = Read-Host "New description for '$($task.Subtasks[$idx].Description)'"
                    if ($newDesc) {$task.Subtasks[$idx].Description = $newDesc; $task.LastModified = Get-Date -F s; Write-Success "Edited."}
                } else { Write-Error "Invalid number."}
            }
            "B" { Save-UnifiedData; return } # Save changes on exit
            default { if ($choice) {Write-Warning "Invalid action."} }
        }
        if ($choice -ne "B" -and $choice -ne "b") { Start-Sleep -Milliseconds 500 }
    }
}

function Remove-Task { # Also for Command Snippets
    param([string]$TaskId)
    if (-not $TaskId) { Write-Error "Task/Snippet ID required."; return }
    $task = $script:Data.Tasks | Where-Object { $_.Id.StartsWith($TaskId) } | Select-Object -First 1
    if (-not $task) { Write-Error "Task/Snippet '$TaskId' not found."; return }

    $type = if ($task.IsCommand) {"Snippet"} else {"Task"}
    Write-Warning "Delete $type: '$($task.Description)'? This is permanent."
    if (-not $task.IsCommand -and $task.TimeSpent -gt 0) { Write-Warning "This task has $($task.TimeSpent) hours logged!"}
    
    $confirm = Read-Host "Type 'yes' to confirm deletion"
    if ($confirm -eq 'yes') {
        $originalCount = $script:Data.Tasks.Count
        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -ne $task.Id }
        if ($script:Data.Tasks.Count -lt $originalCount) {
            if ($task.ProjectKey -and -not $task.IsCommand) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }
            Save-UnifiedData
            Write-Success "$type '$($task.Description)' deleted!"
        } else { Write-Error "Failed to delete (already removed?)."}
    } else { Write-Info "Deletion cancelled." }
}

function Archive-CompletedTasks {
    Write-Header "Archive Completed Tasks"
    $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.AutoArchiveDays)
    $tasksToArchive = $script:Data.Tasks | Where-Object { 
        $_.Completed -and $_.IsCommand -ne $true -and $_.CompletedDate -and ([datetime]::Parse($_.CompletedDate) -lt $cutoffDate)
    }

    if ($tasksToArchive.Count -eq 0) {
        Write-Info "No tasks older than $($script:Data.Settings.AutoArchiveDays) days are ready for automatic archiving."
        $allCompleted = $script:Data.Tasks | Where-Object {$_.Completed -and $_.IsCommand -ne $true}
        if ($allCompleted.Count -gt 0) {
            Write-Host "Archive all $($allCompleted.Count) completed tasks now? (Y/N)"
            if ((Read-Host).ToUpper() -eq 'Y') { $tasksToArchive = $allCompleted } else { return }
        } else { return }
    } else {
        Write-Host "Found $($tasksToArchive.Count) task(s) completed before $($cutoffDate.ToString('yyyy-MM-dd')). Archive them? (Y/N)"
        if ((Read-Host).ToUpper() -ne 'Y') { return }
    }
    
    if ($tasksToArchive.Count -gt 0) {
        $script:Data.ArchivedTasks += $tasksToArchive
        $idsToArchive = $tasksToArchive | Select-Object -ExpandProperty Id
        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -notin $idsToArchive }
        
        $affectedProjects = $tasksToArchive | Where-Object { $_.ProjectKey } | Select-Object -ExpandProperty ProjectKey -Unique
        foreach ($pk in $affectedProjects) { Update-ProjectStatistics -ProjectKey $pk }
        
        Save-UnifiedData
        Write-Success "Archived $($tasksToArchive.Count) task(s)."
    } else {
        Write-Info "No tasks were archived."
    }
}

function View-TaskArchive { # UI for this is in ui.ps1, this is just to manage the data/logic if needed separately
    Write-Header "View Archived Tasks"
    # The actual display logic (Show-ArchivedTaskView or similar) would be in ui.ps1
    # This function in core-data might prepare data or handle unarchiving.
    if ($script:Data.ArchivedTasks.Count -eq 0) { Write-Info "Archive is empty."; return }

    # For now, just shows count. UI module will display them.
    Write-Host "There are $($script:Data.ArchivedTasks.Count) tasks in the archive."
    Write-Host "To view details, use the option in the Task Management menu."
    # Potentially add unarchive logic here if desired:
    # $unarchiveId = Read-Host "Enter ID of task to unarchive (or leave blank)"
    # if ($unarchiveId) { ... unarchive logic ... }
}

function Get-TaskStatus { # Helper, used by UI and core logic
    param($Task)
    if ($Task.Completed) { return "Completed" }
    if ($Task.IsCommand) { return "Snippet" } # Special status for commands
    if ($Task.Progress -ge 100) { return "Done" } # Could be different from Completed if manually set
    if ($Task.Progress -gt 0) { return "In Progress" }
    if ($Task.DueDate) {
        try {
            $dueDate = [datetime]::Parse($Task.DueDate).Date
            $today = [datetime]::Today.Date
            if ($dueDate -lt $today) { return "Overdue" }
            if ($dueDate -eq $today) { return "Due Today" }
            if (($dueDate - $today).Days -le (if($script:Data.Settings.DueSoonDays) {$script:Data.Settings.DueSoonDays} else {3})) { return "Due Soon" } # Configurable "Due Soon"
        } catch { /* Ignore parse error for status */ }
    }
    if ($Task.StartDate) {
         try {
            if ([datetime]::Parse($Task.StartDate).Date -gt [datetime]::Today.Date) { return "Scheduled" }
        } catch { /* Ignore parse error */ }
    }
    return "Pending"
}

function Get-PriorityInfo { # Helper, used by UI
    param($Priority)
    switch ($Priority.ToLower()) {
        "critical" { return @{ Color = (Get-ThemeProperty "Palette.ErrorFG"); Icon = "🔥" } } # Using theme colors
        "high"     { return @{ Color = (Get-ThemeProperty "Palette.WarningFG"); Icon = "🔴" } }
        "medium"   { return @{ Color = (Get-ThemeProperty "Palette.InfoFG"); Icon = "🟡" } }
        "low"      { return @{ Color = (Get-ThemeProperty "Palette.SuccessFG"); Icon = "🟢" } } # Or a more subtle green
        default    { return @{ Color = (Get-ThemeProperty "Palette.SubtleFG"); Icon = "⚪" } }
    }
}

#endregion

#region Excel Form Import (from core-data-ps1 (11).txt - largely complete)

function Import-ProjectFromExcel {
    Write-Header "Import Project from Excel Form"
    $filePath = Read-Host "Enter Excel file path"
    if (-not (Test-Path $filePath)) { Write-Error "File not found: $filePath"; return }

    try {
        Write-Info "Reading Excel form..."
        $excel = New-Object -ComObject Excel.Application
        $excel.Visible = $false; $excel.DisplayAlerts = $false
        $workbook = $excel.Workbooks.Open($filePath)
        $wsName = $script:Data.Settings.ExcelFormConfig.WorksheetName
        $worksheet = try { $workbook.Worksheets.Item($wsName) } catch { Write-Warning "Sheet '$wsName' not found, using first sheet."; $workbook.Worksheets.Item(1) }
        
        $projectData = @{ SourceFile = $filePath; ImportedDate = (Get-Date -F s); CreatedDate = (Get-Date -F s); TotalHours=0;ActiveTasks=0;CompletedTasks=0 }
        foreach ($fieldKey in $script:Data.Settings.ExcelFormConfig.StandardFields.Keys) {
            $fConf = $script:Data.Settings.ExcelFormConfig.StandardFields[$fieldKey]
            try {
                $value = ($worksheet.Range($fConf.ValueCell).Text).Trim()
                if ($fConf.LabelCell) {
                    $label = ($worksheet.Range($fConf.LabelCell).Text).Trim()
                    if ($label -and $label -notlike "*$($fConf.Label)*") { Write-Warning "Label mismatch for $($fConf.Label): found '$label'" }
                }
                if ($value) { $projectData[$fConf.Field] = $value }
            } catch { Write-Warning "Could not read field $($fConf.Label) from $($fConf.ValueCell): $_" }
        }
    } catch { Write-Error "Failed to open/read Excel: $_"; return }
    finally {
        if ($workbook) { $workbook.Close($false) }
        if ($excel) { $excel.Quit() }
        # Release COM objects
        if ($worksheet) {[System.Runtime.Interopservices.Marshal]::ReleaseComObject($worksheet) | Out-Null}
        if ($workbook) {[System.Runtime.Interopservices.Marshal]::ReleaseComObject($workbook) | Out-Null}
        if ($excel) {[System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null}
        [System.GC]::Collect(); [System.GC]::WaitForPendingFinalizers()
    }

    Write-Host "`nData read from form:" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")
    $projectData.GetEnumerator() | Where-Object Key -notin @('SourceFile','ImportedDate','CreatedDate','TotalHours','ActiveTasks','CompletedTasks') | ForEach-Object {
        Write-Host "  $($_.Key) : $($_.Value)" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    }

    $projectKey = if ($projectData.Id2) { $projectData.Id2 } elseif ($projectData.Id1) { $projectData.Id1 } else { Read-Host "`nProject Key (identifier for this app)" }
    if ([stringIsNullOrWhiteSpace]($projectKey)) {Write-Error "Project Key is mandatory."; return}

    if ($script:Data.Projects.ContainsKey($projectKey)) {
        Write-Warning "Project '$projectKey' already exists! Overwrite? (Y/N)"
        if ((Read-Host).ToUpper() -ne 'Y') { return }
    }
    # Defaults for missing fields
    if (-not $projectData.Status) { $projectData.Status = "Active" }
    if (-not $projectData.Name) { $projectData.Name = "Imported Project - $projectKey" } # Ensure name exists

    $script:Data.Projects[$projectKey] = $projectData
    Save-UnifiedData
    Write-Success "Project '$($projectData.Name)' (Key: $projectKey) imported successfully!"
}

function Configure-ExcelForm { # From core-data-ps1 (11).txt
    Write-Header "Configure Excel Form Mapping"
    $config = $script:Data.Settings.ExcelFormConfig
    
    $config.WorksheetName = Read-Host "Worksheet name ($($config.WorksheetName))" | ForEach-Object { if ($_) { $_ } else { $config.WorksheetName } }
    
    Write-Host "`nField Mappings (Current: Label Cell, Value Cell). Enter new 'LC,VC' or blank to keep."
    foreach ($fieldKey in $config.StandardFields.Keys) {
        $fConf = $config.StandardFields[$fieldKey]
        $input = Read-Host "$($fConf.Label) ($($fConf.LabelCell),$($fConf.ValueCell))"
        if ($input -match '^([A-Z]+\d+),([A-Z]+\d+)$') {
            $fConf.LabelCell = $Matches[1]; $fConf.ValueCell = $Matches[2]
        } elseif ($input) { Write-Warning "Invalid format. Kept current."}
    }
    Save-UnifiedData
    Write-Success "Excel form mapping saved!"
}

#endregion

#region Excel Copy Job Functions (Migrated from Pmc Mod Base.txt)

function New-ExcelCopyJob {
    Write-Header "Create New Excel Copy Configuration"
    $jobName = Read-Host "Configuration Name (e.g., MonthlyReportCopy)"
    if ([string]::IsNullOrWhiteSpace($jobName)) { Write-Error "Job name cannot be empty."; return }
    if ($script:Data.ExcelCopyJobs.ContainsKey($jobName)) {
        Write-Warning "Configuration '$jobName' already exists. Overwrite? (Y/N)"
        if ((Read-Host).ToUpper() -ne 'Y') { return }
    }

    $config = @{
        SourceWorkbookPath = Read-Host "Source Excel file path"
        SourceSheetName = Read-Host "Source sheet name"
        DestinationWorkbookPath = Read-Host "Destination Excel file path"
        DestinationSheetName = Read-Host "Destination sheet name"
        CopyOperations = @() # Array of @{SourceRange="A1:B5"; DestCell="C1"}
        Options = @{
            MakeExcelVisible = $script:Data.Settings.ExcelCopyJobOptions.DefaultMakeExcelVisible
            OpenDestinationAfterCompletion = $script:Data.Settings.ExcelCopyJobOptions.DefaultOpenDestinationAfterCompletion
            CreateDestinationSheetIfNeeded = $true
            CreateDestinationWorkbookIfNeeded = $true
        }
    }
    if (-not (Test-Path $config.SourceWorkbookPath)) { Write-Warning "Source path does not exist. Please verify."; }
    
    Write-Host "`nDefine copy operations (enter empty source range to finish):"
    $opIndex = 1
    while ($true) {
        $srcRange = Read-Host "Source Range for Op #$opIndex (e.g., A1:A10 or A:A for full column)"
        if ([string]::IsNullOrWhiteSpace($srcRange)) { break }
        $destCell = Read-Host "Destination Start Cell for Op #$opIndex (e.g., B1)"
        if ([string]::IsNullOrWhiteSpace($destCell)) { Write-Warning "Destination cell required. Skipping this operation."; continue }
        $config.CopyOperations += @{ SourceRange = $srcRange; DestinationStartCell = $destCell }
        $opIndex++
    }

    if ($config.CopyOperations.Count -eq 0) { Write-Error "No copy operations defined. Configuration not saved."; return }
    
    $config.Options.MakeExcelVisible = (Read-Host "Make Excel visible during operation? (Y/N, default N)") -eq 'Y'
    $config.Options.OpenDestinationAfterCompletion = (Read-Host "Open destination file after completion? (Y/N, default N)") -eq 'Y'

    $script:Data.ExcelCopyJobs[$jobName] = $config
    Save-UnifiedData
    Write-Success "Excel copy configuration '$jobName' saved with $($config.CopyOperations.Count) operations."
}

function Execute-ExcelCopyJob {
    param([string]$JobName)
    if (-not $JobName) {
        if ($script:Data.ExcelCopyJobs.Count -eq 0) { Write-Warning "No Excel copy jobs configured."; return }
        Write-Host "Available Excel Copy Jobs:"
        $script:Data.ExcelCopyJobs.Keys | ForEach-Object { Write-Host "  - $_" }
        $JobName = Read-Host "Enter job name to execute"
    }
    if (-not $script:Data.ExcelCopyJobs.ContainsKey($JobName)) { Write-Error "Job '$JobName' not found."; return }

    $config = $script:Data.ExcelCopyJobs[$JobName]
    Write-Header "Executing Excel Copy Job: $JobName"
    if (-not (Test-Path $config.SourceWorkbookPath)) { Write-Error "Source workbook not found: $($config.SourceWorkbookPath)"; return }

    $excel = $null; $srcWb = $null; $srcWs = $null; $destWb = $null; $destWs = $null
    try {
        $excel = New-Object -ComObject Excel.Application
        $excel.Visible = $config.Options.MakeExcelVisible; $excel.DisplayAlerts = $false

        Write-Info "Opening source: $($config.SourceWorkbookPath)"
        $srcWb = $excel.Workbooks.Open($config.SourceWorkbookPath)
        $srcWs = $srcWb.Sheets.Item($config.SourceSheetName)

        $destPath = $config.DestinationWorkbookPath
        if (Test-Path $destPath) {
            Write-Info "Opening destination: $destPath"
            $destWb = $excel.Workbooks.Open($destPath)
        } elseif ($config.Options.CreateDestinationWorkbookIfNeeded) {
            Write-Info "Creating new destination workbook: $destPath"
            $destWb = $excel.Workbooks.Add()
        } else { throw "Destination workbook '$destPath' not found and creation is disabled." }

        try { $destWs = $destWb.Sheets.Item($config.DestinationSheetName) }
        catch {
            if ($config.Options.CreateDestinationSheetIfNeeded) {
                Write-Info "Creating destination sheet: $($config.DestinationSheetName)"
                $destWs = $destWb.Sheets.Add()
                $destWs.Name = $config.DestinationSheetName
            } else { throw "Destination sheet '$($config.DestinationSheetName)' not found and creation is disabled." }
        }
        
        Write-Info "Starting $($config.CopyOperations.Count) copy operations..."
        foreach ($op in $config.CopyOperations) {
            Write-Host "  Copying $($op.SourceRange) from '$($srcWs.Name)' to $($op.DestinationStartCell) in '$($destWs.Name)'..." -ForegroundColor Cyan
            try {
                $srcRangeObj = $srcWs.Range($op.SourceRange)
                $destCellObj = $destWs.Range($op.DestinationStartCell)
                # For simplicity, copy values. For formulas/formats, use .Copy() method and $destCellObj as destination.
                $destRangeObj = $destCellObj.Resize($srcRangeObj.Rows.Count, $srcRangeObj.Columns.Count)
                $destRangeObj.Value2 = $srcRangeObj.Value2 # Copies values only
                # $srcRangeObj.Copy($destCellObj) # For full copy including formatting, formulas
            } catch { Write-Error "    Failed to copy operation: $($op.SourceRange) -> $($op.DestinationStartCell). Error: $_" }
        }
        
        if ($destWb.Path -ne $destPath -or -not (Test-Path $destPath)) { $destWb.SaveAs($destPath) } else { $destWb.Save() }
        Write-Success "Excel copy job '$JobName' completed. Destination saved."
        if ($config.Options.OpenDestinationAfterCompletion) { Start-Process $destPath }
    } catch { Write-Error "Excel copy job '$JobName' failed: $_" }
    finally {
        if ($srcWb) { $srcWb.Close($false) }
        if ($destWb -and $destWb.Saved -eq $false) { $destWb.Close($true) } elseif ($destWb) { $destWb.Close($false) }
        if ($excel) { $excel.Quit() }
        # Release COM objects
        ForEach ($obj in @($srcWs, $srcWb, $destWs, $destWb, $excel)) { if($obj){[System.Runtime.InteropServices.Marshal]::ReleaseComObject($obj) | Out-Null} }
        [System.GC]::Collect(); [System.GC]::WaitForPendingFinalizers()
    }
}

function Edit-ExcelCopyJob {
    Write-Warning "Edit Excel Copy Job: Not fully implemented. Recreate job or edit JSON manually for now."
    # For full implementation:
    # 1. List jobs, let user select.
    # 2. Load selected job config into memory.
    # 3. Step through each property (SourcePath, DestPath, Operations, Options) allowing modification.
    #    - For Operations: List current, allow Add, Delete, Modify existing.
    # 4. Save back to $script:Data.ExcelCopyJobs and Save-UnifiedData.
}

function Remove-ExcelCopyJob {
    if ($script:Data.ExcelCopyJobs.Count -eq 0) { Write-Warning "No Excel copy jobs configured."; return }
    Write-Host "Available Excel Copy Jobs:"
    $script:Data.ExcelCopyJobs.Keys | ForEach-Object { Write-Host "  - $_" }
    $jobNameToDelete = Read-Host "Enter job name to delete"

    if ($script:Data.ExcelCopyJobs.ContainsKey($jobNameToDelete)) {
        Write-Warning "Are you sure you want to delete Excel copy job '$jobNameToDelete'? (Y/N)"
        if ((Read-Host).ToUpper() -eq 'Y') {
            $script:Data.ExcelCopyJobs.Remove($jobNameToDelete)
            Save-UnifiedData
            Write-Success "Job '$jobNameToDelete' deleted."
        } else { Write-Info "Deletion cancelled." }
    } else { Write-Error "Job '$jobNameToDelete' not found." }
}

#endregion

#region Settings Functions (Task Settings, from Pmc Mod Base.txt)

function Edit-TaskSettings {
    Write-Header "Task Settings"
    $settings = $script:Data.Settings # Shortcut
    
    Write-Host "Leave empty to keep current value." -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
   
    $settings.DefaultPriority = Read-Host "`nDefault priority ($($settings.DefaultPriority)): [C]rit, [H]igh, [M]ed, [L]ow" | ForEach-Object {
        if ([string]::IsNullOrWhiteSpace($_)) { $settings.DefaultPriority }
        else { (switch ($_.ToUpper()) {"C"{"Critical"}"H"{"High"}"M"{"Medium"}"L"{"Low"} default {$settings.DefaultPriority}}) }
    }
    $settings.DefaultCategory = Read-Host "`nDefault category ($($settings.DefaultCategory))" | ForEach-Object { if ($_) { $_ } else { $settings.DefaultCategory } }
    
    $newShowDays = Read-Host "`nShow completed tasks for days ($($settings.ShowCompletedDays))"
    if ($newShowDays -match '^\d+$') { $settings.ShowCompletedDays = [int]$newShowDays }
    
    $newArchiveDays = Read-Host "`nAuto-archive completed tasks older than days ($($settings.AutoArchiveDays))"
    if ($newArchiveDays -match '^\d+$') { $settings.AutoArchiveDays = [int]$newArchiveDays }

    $settings.EnableTimeTracking = (Read-Host "`nEnable linking tasks to time entries? (Y/N, current: $($settings.EnableTimeTracking))") `
        | ForEach-Object { if ($_) { $_.ToUpper() -eq 'Y' } else { $settings.EnableTimeTracking } }

    Save-UnifiedData
    Write-Success "Task settings updated!"
}

#endregion
# core-time.ps1
# Core Time Tracking and Time-based Reporting Logic

#region Formatted Timesheet Export (Requirement I)

function Export-FormattedTimesheet {
    param(
        [DateTime]$WeekStartDate = (Get-WeekStart $script:Data.CurrentWeek) # Use current report week
    )
    Write-Header "Export Formatted Timesheet for week starting: $($WeekStartDate.ToString('yyyy-MM-dd'))"

    $weekDates = @(0..4 | ForEach-Object { $WeekStartDate.AddDays($_) }) # Mon-Fri

    $timeEntriesForWeek = $script:Data.TimeEntries | Where-Object {
        $entryDate = [DateTime]::Parse($_.Date)
        $entryDate -ge $weekDates[0] -and $entryDate -le $weekDates[4]
    }

    if ($timeEntriesForWeek.Count -eq 0) {
        Write-Warning "No time entries found for the week of $($WeekStartDate.ToString('yyyy-MM-dd')). Nothing to export."
        return
    }

    # Group entries by ProjectKey, then by day
    $reportData = @{} # Hashtable: Key = ProjectKey, Value = Hashtable (DayOfWeek -> Hours)
    foreach ($entry in $timeEntriesForWeek) {
        if (-not $reportData.ContainsKey($entry.ProjectKey)) {
            $reportData[$entry.ProjectKey] = @{ Mon = 0.0; Tue = 0.0; Wed = 0.0; Thu = 0.0; Fri = 0.0 }
        }
        $dayIndex = ([datetime]::Parse($entry.Date).DayOfWeek - [DayOfWeek]::Monday + 7) % 7 # Mon=0, Tue=1..
        if ($dayIndex -ge 0 -and $dayIndex -le 4) { # Only Mon-Fri
            $dayKey = @("Mon", "Tue", "Wed", "Thu", "Fri")[$dayIndex]
            $reportData[$entry.ProjectKey][$dayKey] += [double]$entry.Hours
        }
    }

    $csvOutput = @()
    # Header row as specified: ID1,ID2,,,,Mon,Tue,Wed,Thu,Fri
    $csvOutput += "ID1,ID2,,,,Mon,Tue,Wed,Thu,Fri" 

    foreach ($projKey in $reportData.Keys | Sort-Object) {
        $project = Get-ProjectOrTemplate $projKey # Assumes Get-ProjectOrTemplate from core-data.ps1
        if (-not $project) { Write-Warning "Project data for key '$projKey' not found. Skipping."; continue }
        
        $id1 = if ($project.Id1) { $project.Id1 } else { "" }
        $id2 = if ($project.Id2) { $project.Id2 } else { $projKey } # Fallback to project key if Id2 is missing

        $line = """$id1"",""$id2"",,,," # Using quotes for safety if IDs contain commas
        $line += "$($reportData[$projKey].Mon.ToString('F2')),"
        $line += "$($reportData[$projKey].Tue.ToString('F2')),"
        $line += "$($reportData[$projKey].Wed.ToString('F2')),"
        $line += "$($reportData[$projKey].Thu.ToString('F2')),"
        $line += "$($reportData[$projKey].Fri.ToString('F2'))"
        $csvOutput += $line
    }
    
    if ($csvOutput.Count -le 1) { # Only header means no actual data
        Write-Warning "No processable project time entries found for the timesheet."
        return
    }

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $fileName = "FormattedTimesheet_Week-$($WeekStartDate.ToString('yyyyMMdd'))_$timestamp.csv"
    $desktopPath = [Environment]::GetFolderPath("Desktop")
    $filePath = Join-Path $desktopPath $fileName

    try {
        $csvOutput | Set-Content -Path $filePath -Encoding UTF8
        Write-Success "Formatted timesheet exported to: $filePath"
        if (Test-Path $filePath) {
            # Ask to open
            Write-Host "Open the exported file? (Y/N)" -NoNewline
            if ((Read-Host).ToUpper() -eq 'Y') {
                Start-Process $filePath
            }
        }
    } catch {
        Write-Error "Failed to export timesheet: $_"
    }
}

#endregion

#region Core Time Tracking Logic (Migrated from Pmc Mod Base.txt)

function Add-ManualTimeEntry {
    Write-Header "Manual Time Entry"
    Show-ProjectsAndTemplates -Simple # UI function
   
    $projectKey = Read-Host "`nProject/Template Key"
    $project = Get-ProjectOrTemplate $projectKey # core-data.ps1
    if (-not $project) { Write-Error "Project '$projectKey' not found."; return }
   
    $dateStr = Read-Host "Date (YYYY-MM-DD, 'today', 'yesterday', or Enter for today)"
    $date = if ([string]::IsNullOrWhiteSpace($dateStr)) { [DateTime]::Today.Date } 
            else { try { Parse-SmartDate $dateStr } catch { Write-Error "Invalid date: $_"; return }} # core-data.ps1
    if (-not $date) {Write-Error "Date could not be parsed."; return }

    Write-Host "Enter time as hours (e.g., 2.5) or range (e.g., 09:00-11:30)"
    $timeInput = Read-Host "Time"
    $hours = 0.0; $startTime = ""; $endTime = ""
   
    if ($timeInput -match '(\d{1,2}:\d{2})-(\d{1,2}:\d{2})') {
        try {
            $start = [DateTime]::Parse("$($date.ToString('yyyy-MM-dd')) $($Matches[1])")
            $end = [DateTime]::Parse("$($date.ToString('yyyy-MM-dd')) $($Matches[2])")
            if ($end -lt $start) { $end = $end.AddDays(1) } # Handle overnight
            $hours = ($end - $start).TotalHours; $startTime = $Matches[1]; $endTime = $Matches[2]
            Write-Info "Calculated hours: $([Math]::Round($hours, 2))"
        } catch { Write-Error "Invalid time range format: $_"; return }
    } elseif ($timeInput -match '^\d+(\.\d+)?$') {
        $hours = [double]$timeInput
    } else { Write-Error "Invalid time input format."; return }
   
    $description = Read-Host "Description (optional)"
    $taskId = $null
    Write-Host "`nLink to a task for project '$($project.Name)'? (Y/N)"
    if ((Read-Host).ToUpper() -eq 'Y') {
        $projectTasks = $script:Data.Tasks | Where-Object { $_.ProjectKey -eq $projectKey -and (-not $_.Completed) -and ($_.IsCommand -ne $true) }
        if ($projectTasks.Count -gt 0) {
            Write-Host "`nActive tasks for '$($project.Name)':"
            $projectTasks | ForEach-Object {$idx=0} { Write-Host "  [$($idx++)] ($($_.Id.Substring(0,6))) $($_.Description)" } # Show temp index for easy selection
            $taskSelection = Read-Host "`nTask ID (partial ID or #)"
            $matchedTask = $null
            if ($taskSelection -match '^\d+$' -and [int]$taskSelection -lt $projectTasks.Count) {
                $matchedTask = $projectTasks[[int]$taskSelection]
            } else {
                $matchedTask = $projectTasks | Where-Object { $_.Id.StartsWith($taskSelection) } | Select-Object -First 1
            }

            if ($matchedTask) { $taskId = $matchedTask.Id; $matchedTask.TimeSpent = [Math]::Round($matchedTask.TimeSpent + $hours, 2) }
            else { Write-Warning "Task not found. No task link." }
        } else { Write-Info "No active, non-command tasks for this project to link."}
    }
   
    $entry = @{
        Id = New-TodoId; ProjectKey = $projectKey; TaskId = $taskId # New-TodoId from helper.ps1
        Date = $date.ToString("yyyy-MM-dd"); Hours = [Math]::Round($hours, 2)
        Description = $description; StartTime = $startTime; EndTime = $endTime
        EnteredAt = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    $script:Data.TimeEntries += $entry
    Update-ProjectStatistics -ProjectKey $projectKey # core-data.ps1
    Save-UnifiedData # helper.ps1
    Write-Success "Time entry added: $($entry.Hours) hours for $($project.Name) on $($date.ToString('yyyy-MM-dd'))"
    Show-BudgetWarning -ProjectKey $projectKey
}

function Start-Timer {
    param([string]$ProjectKey, [string]$TaskId, [string]$Description)
    if (-not $ProjectKey -and -not $TaskId) {
        Write-Header "Start Timer"
        # UI Logic to select project/task would be here or in ui.ps1, then call this with params
        # For now, keeping it simple as per Pmc Mod Base structure
        Show-ProjectsAndTemplates -Simple
        $ProjectKey = Read-Host "`nProject/Template Key"
        if (-not (Get-ProjectOrTemplate $ProjectKey)) { Write-Error "Project not found."; return }
        # Could add task selection here too.
    }
    if (-not $Description) { $Description = Read-Host "Description for timer (optional)" }

    $timerKey = if ($TaskId) { $TaskId } else { $ProjectKey } # Timer identified by Task ID if present, else Project Key
    if ($script:Data.ActiveTimers.ContainsKey($timerKey)) { Write-Warning "Timer already running for '$timerKey'!"; return }

    $timer = @{ StartTime = Get-Date; ProjectKey = $ProjectKey; TaskId = $TaskId; Description = $Description }
    $script:Data.ActiveTimers[$timerKey] = $timer
    Save-UnifiedData
    $projName = (Get-ProjectOrTemplate $ProjectKey).Name
    Write-Success "Timer started for '$projName' ($timerKey) at $(Get-Date -Format 'HH:mm:ss')."
}

function Stop-Timer {
    param([string]$TimerKeyToStop) # Can be project key or task ID
    if ($script:Data.ActiveTimers.Count -eq 0) { Write-Warning "No active timers."; return }

    if (-not $TimerKeyToStop) {
        Show-ActiveTimers # UI function
        $TimerKeyToStop = Read-Host "`nEnter Timer Key (Project Key or Task ID) to stop, or 'all'"
    }
    if ([string]::IsNullOrWhiteSpace($TimerKeyToStop)) { return }

    if ($TimerKeyToStop.ToLower() -eq 'all') {
        $keysToStop = @($script:Data.ActiveTimers.Keys) # Copy keys as collection changes
        foreach ($key in $keysToStop) { Stop-SingleTimer -Key $key -Silent }
        Write-Success "Stopped all ($($keysToStop.Count)) active timers."
    } else {
        if ($script:Data.ActiveTimers.ContainsKey($TimerKeyToStop)) {
            Stop-SingleTimer -Key $TimerKeyToStop
        } else { Write-Error "Timer with key '$TimerKeyToStop' not found." }
    }
    Save-UnifiedData
}

function Stop-SingleTimer {
    param([string]$Key, [switch]$Silent)
    if (-not $script:Data.ActiveTimers.ContainsKey($Key)) {
        if (-not $Silent) { Write-Error "Timer key '$Key' not found in active timers." }
        return
    }
    $timer = $script:Data.ActiveTimers[$Key]
    $endTime = Get-Date
    $duration = ($endTime - [DateTime]$timer.StartTime).TotalHours

    $entry = @{
        Id = New-TodoId; ProjectKey = $timer.ProjectKey; TaskId = $timer.TaskId
        Date = $endTime.Date.ToString("yyyy-MM-dd"); Hours = [Math]::Round($duration, 2)
        StartTime = ([DateTime]$timer.StartTime).ToString("HH:mm"); EndTime = $endTime.ToString("HH:mm")
        Description = $timer.Description; EnteredAt = (Get-Date -F s)
    }
    $script:Data.TimeEntries += $entry
    if ($timer.TaskId) {
        $task = $script:Data.Tasks | Where-Object { $_.Id -eq $timer.TaskId } | Select-Object -First 1
        if ($task) { $task.TimeSpent = [Math]::Round($task.TimeSpent + $duration, 2) }
    }
    Update-ProjectStatistics -ProjectKey $timer.ProjectKey # core-data.ps1
    $script:Data.ActiveTimers.Remove($Key)
    
    if (-not $Silent) {
        $projName = (Get-ProjectOrTemplate $timer.ProjectKey).Name
        Write-Success "Timer for '$projName' ($Key) stopped. Duration: $($entry.Hours) hours."
        Show-BudgetWarning -ProjectKey $timer.ProjectKey
    }
}

function Quick-TimeEntry {
    param([string]$Input) # Format: PROJECT_KEY HOURS [DESCRIPTION]
    $parts = $Input -split ' ', 3
    if ($parts.Count -lt 2) { Write-Error "Format: PROJECT_KEY HOURS [DESCRIPTION]"; return }
    $projectKey = $parts[0]
    try { $hours = [double]$parts[1] } catch { Write-Error "Invalid hours format."; return }
    $description = if ($parts.Count -eq 3) { $parts[2] } else { "" }

    $project = Get-ProjectOrTemplate $projectKey # core-data.ps1
    if (-not $project) { Write-Error "Project '$projectKey' not found."; return }

    $entry = @{
        Id = New-TodoId; ProjectKey = $projectKey; TaskId = $null
        Date = (Get-Date).Date.ToString("yyyy-MM-dd"); Hours = [Math]::Round($hours, 2)
        Description = $description; StartTime = ""; EndTime = ""
        EnteredAt = (Get-Date -F s)
    }
    $script:Data.TimeEntries += $entry
    Update-ProjectStatistics -ProjectKey $projectKey # core-data.ps1
    Save-UnifiedData # helper.ps1
    Write-Success "Quick entry: $hours hours for $($project.Name)"
}

function Show-BudgetWarning { # Helper function, typically called after adding time
    param([string]$ProjectKey)
    $project = $script:Data.Projects[$ProjectKey] # Assumes it's a project, not template
    if (-not $project -or $project.BillingType -eq "Non-Billable" -or -not $project.Budget -or $project.Budget -eq 0) { return }
    
    Update-ProjectStatistics -ProjectKey $ProjectKey # Ensure stats are fresh
    $percentUsed = ($project.TotalHours / $project.Budget) * 100
   
    if ($percentUsed -ge 100) {
        Write-Error "BUDGET EXCEEDED for $($project.Name): $([Math]::Round($percentUsed,1))% used. Budget: $($project.Budget)h, Spent: $($project.TotalHours)h."
    } elseif ($percentUsed -ge 90) {
        Write-Warning "Budget alert for $($project.Name): $([Math]::Round($percentUsed,1))% used. Remaining: $([Math]::Round($project.Budget - $project.TotalHours, 2))h."
    } elseif ($percentUsed -ge 75) {
        Write-Warning "Budget notice for $($project.Name): $([Math]::Round($percentUsed,1))% used."
    }
}

function Edit-TimeEntry {
    Write-Header "Edit Time Entry"
    # UI for selecting an entry should precede this call.
    # This function would take an $EntryId or $EntryObject parameter.
    # For brevity, showing conceptual logic for an identified entry.
    Write-Warning "Edit Time Entry: Select entry via 'Today's Log' or Reports, then use context menu (not fully implemented here)."
    # Example:
    # param($EntryIdToEdit)
    # $entry = $script:Data.TimeEntries | Where-Object {$_.Id -eq $EntryIdToEdit} | Select-Object -First 1
    # if (-not $entry) { Write-Error "Entry not found."; return }
    # ... (logic like in Pmc Mod Base) ...
}

function Delete-TimeEntry {
    Write-Header "Delete Time Entry"
    Write-Warning "Delete Time Entry: Select entry via 'Today's Log' or Reports, then use context menu (not fully implemented here)."
    # ... (similar to Edit-TimeEntry, requires UI selection first) ...
}

#endregion

#region Time-based Reporting Data Functions (Migrated from Pmc Mod Base.txt)
# These functions prepare data or perform calculations for reports.
# The actual display (Write-Host, Format-TableUnicode) will be in ui.ps1 or main.ps1 orchestrating UI.

function Get-WeekReportData { # Data gathering for Show-WeekReport
    param([DateTime]$WeekStartDate = $script:Data.CurrentWeek)
    $weekDates = Get-WeekDates $WeekStartDate # helper.ps1
    $weekEntries = $script:Data.TimeEntries | Where-Object {
        $entryDate = [DateTime]::Parse($_.Date)
        $entryDate -ge $weekDates[0] -and $entryDate -le $weekDates[4] # Mon-Fri
    }
    if ($weekEntries.Count -eq 0) { return $null }

    $projectHours = @{} # Key: ProjectKey, Value: @{Mon=h, Tue=h ... Total=h, Billable=b, Value=v}
    foreach ($entry in $weekEntries) {
        if (-not $projectHours.ContainsKey($entry.ProjectKey)) {
            $projectInfo = Get-ProjectOrTemplate $entry.ProjectKey
            $projectHours[$entry.ProjectKey] = @{
                Name = $projectInfo.Name; Id1 = $projectInfo.Id1; Id2 = $projectInfo.Id2
                Client = $projectInfo.Client; Department = $projectInfo.Department
                IsBillable = ($projectInfo.BillingType -eq "Billable"); Rate = $projectInfo.Rate
                Mon = 0.0; Tue = 0.0; Wed = 0.0; Thu = 0.0; Fri = 0.0; Total = 0.0; Value = 0.0
            }
        }
        $dayIndex = ([datetime]::Parse($entry.Date).DayOfWeek - [DayOfWeek]::Monday + 7) % 7
        if ($dayIndex -ge 0 -and $dayIndex -le 4) {
            $dayKey = @("Mon", "Tue", "Wed", "Thu", "Fri")[$dayIndex]
            $projectHours[$entry.ProjectKey][$dayKey] +=



```powershell
# core-time.ps1 (Continued)
            $projectHours[$entry.ProjectKey][$dayKey] = [Math]::Round($projectHours[$entry.ProjectKey][$dayKey], 2)
        }
    }
    # Calculate totals and value
    foreach ($key in $projectHours.Keys) {
        $projData = $projectHours[$key]
        $projData.Total = $projData.Mon + $projData.Tue + $projData.Wed + $projData.Thu + $projData.Fri
        if ($projData.IsBillable) {
            $projData.Value = $projData.Total * $projData.Rate
        }
    }
    return $projectHours.Values | Sort-Object Name
}

function Get-ExtendedReportData { # Data gathering for Show-ExtendedReport
    param([DateTime]$WeekStartDate = $script:Data.CurrentWeek)
    $weekDates = Get-WeekDates $WeekStartDate # Mon-Fri
    $allEntries = $script:Data.TimeEntries | Where-Object {
        $entryDate = [DateTime]::Parse($_.Date)
        $entryDate -ge $weekDates[0] -and $entryDate -le $weekDates[4]
    } | Sort-Object Date, StartTime
    
    return $allEntries # UI module will group and display
}

function Get-TodayTimeLogData { # Data for Show-TodayTimeLog
    $today = (Get-Date).ToString("yyyy-MM-dd")
    return $script:Data.TimeEntries | Where-Object { $_.Date -eq $today } | Sort-Object StartTime, EnteredAt
}

function Get-MonthSummaryData { # Data for Show-MonthSummary
    param([DateTime]$MonthDate = (Get-Date)) # Any date within the target month
    $monthStart = Get-Date $MonthDate -Day 1 -Hour 0 -Minute 0 -Second 0
    $monthEnd = $monthStart.AddMonths(1).AddDays(-1).AddHours(23).AddMinutes(59).AddSeconds(59) # End of last day of month

    $monthEntries = $script:Data.TimeEntries | Where-Object {
        $date = [DateTime]::Parse($_.Date)
        $date -ge $monthStart -and $date -le $monthEnd
    }
    return $monthEntries # UI module will group by project and display
}

function Get-ProjectSummaryData { # Data for Show-ProjectSummary
    # This function would iterate through $script:Data.Projects
    # and for each, gather related time entries to sum up hours.
    # Update-ProjectStatistics in core-data.ps1 already does this and stores on project object.
    # So, this function might just return $script:Data.Projects.Values
    # after ensuring all stats are updated.
    $script:Data.Projects.Values | ForEach-Object { Update-ProjectStatistics -ProjectKey $_.PSObject.Properties["Key"].Value } # Assuming Key is present if it's from a hashtable enumerator
    return $script:Data.Projects.Values | Sort-Object Status, Name
}

function Get-TimeAnalyticsData { # Data for Show-TimeAnalytics
    # Gathers various time stats for the UI to display
    $last30DaysEntries = $script:Data.TimeEntries | Where-Object {
        [DateTime]::Parse($_.Date) -ge (Get-Date).AddDays(-30).Date
    }
    # Further processing (by day of week, top projects) can be done here or in UI based on this raw data.
    return @{
        Last30DaysEntries = $last30DaysEntries
        # Could add more aggregated data here if useful for UI
    }
}

#endregion

#region Settings Functions (Time Tracking Settings, from Pmc Mod Base.txt)

function Edit-TimeTrackingSettings {
    Write-Header "Time Tracking Settings"
    $settings = $script:Data.Settings # Shortcut
    
    Write-Host "Leave empty to keep current value." -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
   
    $newRate = Read-Host "`nDefault hourly rate ($($settings.DefaultRate))"
    if ($newRate -match '^\d+(\.\d+)?$') { $settings.DefaultRate = [double]$newRate } 
    elseif ($newRate) { Write-Warning "Invalid rate. Kept current."}

    $newHoursDay = Read-Host "`nHours per day (target for reports) ($($settings.HoursPerDay))"
    if ($newHoursDay -match '^\d+(\.\d+)?$') { $settings.HoursPerDay = [double]$newHoursDay }
    elseif ($newHoursDay) { Write-Warning "Invalid hours. Kept current."}
    
    $newDaysWeek = Read-Host "`nDays per week (target for reports) ($($settings.DaysPerWeek))"
    if ($newDaysWeek -match '^\d$') { $settings.DaysPerWeek = [int]$newDaysWeek }
    elseif ($newDaysWeek) { Write-Warning "Invalid days. Kept current."}

    $settings.Currency = Read-Host "`nCurrency symbol ($($settings.Currency))" | ForEach-Object { if ($_) { $_ } else { $settings.Currency } }

    Write-Host "`nEdit Project Templates? (Y/N)"
    if((Read-Host).ToUpper() -eq 'Y') {
        Manage-ProjectTemplates
    }

    Save-UnifiedData
    Write-Success "Time tracking settings updated!"
}

function Manage-ProjectTemplates {
    Write-Header "Manage Project Templates"
    # List current templates
    # Options: Add, Edit, Delete template
    # Similar CRUD operations as for regular projects but on $script:Data.Settings.TimeTrackerTemplates
    Write-Warning "Template management not fully implemented in this stub."
    # Example list:
    # foreach($key in $script:Data.Settings.TimeTrackerTemplates.Keys | Sort-Object) {
    #    $template = $script:Data.Settings.TimeTrackerTemplates[$key]
    #    Write-Host "[$key] $($template.Name) - $($template.BillingType)"
    # }
}

#endregion
# Helper Functions Module
# Utility functions for file I/O, date handling, validation, etc.

#region Configuration

$script:DataPath = Join-Path $env:USERPROFILE ".ProductivitySuite"
$script:UnifiedDataFile = Join-Path $script:DataPath "unified_data.json"
$script:ConfigFile = Join-Path $script:DataPath "config.json"
$script:BackupPath = Join-Path $script:DataPath "backups"
$script:ExcelCopyConfigFile = Join-Path $script:DataPath "excelcopy_configs.json"

# Ensure directories exist
@($script:DataPath, $script:BackupPath) | ForEach-Object {
    if (-not (Test-Path $_)) {
        New-Item -ItemType Directory -Path $_ -Force | Out-Null
    }
}

#endregion

#region Data Persistence

function Load-UnifiedData {
    try {
        if (Test-Path $script:UnifiedDataFile) {
            $loaded = Get-Content $script:UnifiedDataFile | ConvertFrom-Json -AsHashtable
            
            # Deep merge to preserve structure
            foreach ($key in $loaded.Keys) {
                if ($key -eq "Settings" -and $script:Data.ContainsKey($key)) {
                    # Merge settings carefully to preserve defaults
                    foreach ($settingKey in $loaded.Settings.Keys) {
                        $script:Data.Settings[$settingKey] = $loaded.Settings[$settingKey]
                    }
                } else {
                    $script:Data[$key] = $loaded[$key]
                }
            }
            
            # Ensure CurrentWeek is a DateTime
            if ($script:Data.CurrentWeek -is [string]) {
                $script:Data.CurrentWeek = [DateTime]::Parse($script:Data.CurrentWeek)
            }
        }
    } catch {
        Write-Warning "Could not load data, starting fresh: $_"
    }
}

function Save-UnifiedData {
    try {
        # Auto-backup
        if ((Get-Random -Maximum 10) -eq 0 -or -not (Test-Path $script:UnifiedDataFile)) {
            Backup-Data -Silent
        }
        
        $script:Data | ConvertTo-Json -Depth 10 | Set-Content $script:UnifiedDataFile
    } catch {
        Write-Error "Failed to save data: $_"
    }
}

function Backup-Data {
    param([switch]$Silent)
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $backupFile = Join-Path $script:BackupPath "backup_$timestamp.json"
    
    try {
        $script:Data | ConvertTo-Json -Depth 10 | Set-Content $backupFile
        if (-not $Silent) {
            Write-Success "Backup created: $backupFile"
        }
        
        # Keep only last 30 backups
        Get-ChildItem $script:BackupPath -Filter "backup_*.json" |
            Sort-Object CreationTime -Descending |
            Select-Object -Skip 30 |
            Remove-Item -Force
    } catch {
        Write-Error "Backup failed: $_"
    }
}

function Restore-FromBackup {
    Write-Header "Restore from Backup"
    
    $backups = Get-ChildItem $script:BackupPath -Filter "backup_*.json" | Sort-Object CreationTime -Descending
    
    if ($backups.Count -eq 0) {
        Write-Warning "No backups found"
        return
    }
    
    Write-Host "Available backups:"
    for ($i = 0; $i -lt $backups.Count; $i++) {
        $backup = $backups[$i]
        $date = $backup.CreationTime.ToString("yyyy-MM-dd HH:mm:ss")
        $size = [Math]::Round($backup.Length / 1KB, 2)
        Write-Host "  [$i] $date ($size KB)"
    }
    
    $index = Read-Host "`nSelect backup number"
    try {
        $idx = [int]$index
        if ($idx -ge 0 -and $idx -lt $backups.Count) {
            $selectedBackup = $backups[$idx]
            
            Write-Warning "This will replace all current data! Type 'yes' to confirm"
            $confirm = Read-Host
            
            if ($confirm -eq 'yes') {
                # Backup current data first
                Backup-Data -Silent
                
                # Load backup
                $backupData = Get-Content $selectedBackup.FullName | ConvertFrom-Json -AsHashtable
                $script:Data = $backupData
                Save-UnifiedData
                
                Write-Success "Data restored from backup!"
                Write-Info "A backup of your previous data was created."
            }
        }
    } catch {
        Write-Error "Invalid selection"
    }
}

#endregion

#region ID Generation

function New-TodoId {
    return [System.Guid]::NewGuid().ToString().Substring(0, 8)
}

function Format-Id2 {
    param([string]$Id2)
    
    if ($Id2.Length -gt 9) {
        $Id2 = $Id2.Substring(0, 9)
    }
    
    $paddingNeeded = 12 - 2 - $Id2.Length
    $zeros = "0" * $paddingNeeded
    
    return "V${zeros}${Id2}S"
}

#endregion

#region Date Functions

function Get-WeekStart {
    param([DateTime]$Date = (Get-Date))
    
    $daysFromMonday = [int]$Date.DayOfWeek
    if ($daysFromMonday -eq 0) { $daysFromMonday = 7 }
    $monday = $Date.AddDays(1 - $daysFromMonday)
    
    return Get-Date $monday -Hour 0 -Minute 0 -Second 0
}

function Get-WeekDates {
    param([DateTime]$WeekStart)
    
    return @(0..4 | ForEach-Object { $WeekStart.AddDays($_) })
}

function Format-TodoDate {
    param($DateString)
    if ([string]::IsNullOrEmpty($DateString)) { return "" }
    try {
        $date = [datetime]::Parse($DateString)
        $today = [datetime]::Today
        $diff = ($date - $today).Days
        
        $dateStr = $date.ToString("MMM dd")
        if ($diff -eq 0) { return "Today" }
        elseif ($diff -eq 1) { return "Tomorrow" }
        elseif ($diff -eq -1) { return "Yesterday" }
        elseif ($diff -gt 0 -and $diff -le 7) { return "$dateStr (in $diff days)" }
        elseif ($diff -lt 0) {
            $absDiff = [Math]::Abs($diff)
            return "$dateStr ($absDiff days ago)"
        }
        else { return $dateStr }
    }
    catch { return $DateString }
}

function Get-NextWeekday {
    param([int]$TargetDay)
    
    $today = [datetime]::Today
    $currentDay = [int]$today.DayOfWeek
    $daysToAdd = ($TargetDay - $currentDay + 7) % 7
    if ($daysToAdd -eq 0) { $daysToAdd = 7 }
    
    return $today.AddDays($daysToAdd)
}

#endregion

#region Validation Functions

function Test-ExcelConnection {
    Write-Header "Test Excel Connection"
    
    try {
        Write-Info "Testing Excel COM object creation..."
        $excel = New-Object -ComObject Excel.Application
        Write-Success "Excel COM object created successfully!"
        
        Write-Info "Excel version: $($excel.Version)"
        
        $excel.Quit()
        [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null
        
        Write-Success "Excel connection test passed!"
    } catch {
        Write-Error "Excel connection test failed: $_"
        Write-Warning "Make sure Microsoft Excel is installed on this system."
    }
}

#endregion

#region Import/Export Functions

function Export-AllData {
    Write-Header "Export All Data"
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $exportPath = Join-Path ([Environment]::GetFolderPath("Desktop")) "ProductivitySuite_Export_$timestamp"
    New-Item -ItemType Directory -Path $exportPath -Force | Out-Null
    
    # Export main data
    $script:Data | ConvertTo-Json -Depth 10 | Set-Content (Join-Path $exportPath "unified_data.json")
    
    # Export time entries as CSV
    if ($script:Data.TimeEntries.Count -gt 0) {
        $timeExport = $script:Data.TimeEntries | ForEach-Object {
            $project = Get-ProjectOrTemplate $_.ProjectKey
            [PSCustomObject]@{
                Date = $_.Date
                ProjectKey = $_.ProjectKey
                ProjectName = $project.Name
                Hours = $_.Hours
                Description = $_.Description
                TaskId = $_.TaskId
                StartTime = $_.StartTime
                EndTime = $_.EndTime
            }
        }
        $timeExport | Export-Csv (Join-Path $exportPath "time_entries.csv") -NoTypeInformation
    }
    
    # Export tasks as CSV
    if ($script:Data.Tasks.Count -gt 0) {
        $taskExport = $script:Data.Tasks | ForEach-Object {
            $project = if ($_.ProjectKey) { Get-ProjectOrTemplate $_.ProjectKey } else { $null }
            [PSCustomObject]@{
                Id = $_.Id
                Description = $_.Description
                Priority = $_.Priority
                Category = $_.Category
                ProjectName = if ($project) { $project.Name } else { "" }
                Status = Get-TaskStatus $_
                DueDate = $_.DueDate
                Progress = $_.Progress
                TimeSpent = $_.TimeSpent
                EstimatedTime = $_.EstimatedTime
                Tags = $_.Tags -join ","
            }
        }
        $taskExport | Export-Csv (Join-Path $exportPath "tasks.csv") -NoTypeInformation
    }
    
    # Export projects as CSV
    if ($script:Data.Projects.Count -gt 0) {
        $projectExport = $script:Data.Projects.GetEnumerator() | ForEach-Object {
            $proj = $_.Value
            [PSCustomObject]@{
                Key = $_.Key
                Name = $proj.Name
                Id1 = $proj.Id1
                Id2 = $proj.Id2
                Client = $proj.Client
                Department = $proj.Department
                Status = $proj.Status
                BillingType = $proj.BillingType
                Rate = $proj.Rate
                Budget = $proj.Budget
                TotalHours = $proj.TotalHours
                ActiveTasks = $proj.ActiveTasks
                CompletedTasks = $proj.CompletedTasks
            }
        }
        $projectExport | Export-Csv (Join-Path $exportPath "projects.csv") -NoTypeInformation
    }
    
    # Export command snippets
    $commands = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }
    if ($commands.Count -gt 0) {
        $commandExport = $commands | ForEach-Object {
            [PSCustomObject]@{
                Id = $_.Id
                Name = $_.Description
                Command = $_.Notes
                Category = $_.Category
                Tags = $_.Tags -join ","
                Hotkey = if ($_.Hotkey) { $_.Hotkey } else { "" }
                CreatedDate = $_.CreatedDate
            }
        }
        $commandExport | Export-Csv (Join-Path $exportPath "command_snippets.csv") -NoTypeInformation
    }
    
    Write-Success "Data exported to: $exportPath"
    
    # Open folder
    Start-Process $exportPath
}

function Import-Data {
    Write-Header "Import Data"
    
    Write-Warning "This will merge imported data with existing data."
    Write-Host "Enter path to unified_data.json file:"
    $importPath = Read-Host
    
    if (-not (Test-Path $importPath)) {
        Write-Error "File not found!"
        return
    }
    
    try {
        # Backup current data first
        Backup-Data -Silent
        
        $importData = Get-Content $importPath | ConvertFrom-Json -AsHashtable
        
        Write-Host "`nImport options:"
        Write-Host "[1] Merge with existing data"
        Write-Host "[2] Replace all data"
        Write-Host "[3] Cancel"
        
        $choice = Read-Host "Choice"
        
        switch ($choice) {
            "1" {
                # Merge data
                if ($importData.Projects) {
                    foreach ($key in $importData.Projects.Keys) {
                        if (-not $script:Data.Projects.ContainsKey($key)) {
                            $script:Data.Projects[$key] = $importData.Projects[$key]
                            Write-Success "Imported project: $key"
                        } else {
                            Write-Warning "Skipped existing project: $key"
                        }
                    }
                }
                
                if ($importData.Tasks) {
                    $existingIds = $script:Data.Tasks | ForEach-Object { $_.Id }
                    $imported = 0
                    foreach ($task in $importData.Tasks) {
                        if ($task.Id -notin $existingIds) {
                            $script:Data.Tasks += $task
                            $imported++
                        }
                    }
                    Write-Success "Imported $imported new tasks"
                }
                
                if ($importData.TimeEntries) {
                    $existingIds = $script:Data.TimeEntries | ForEach-Object { $_.Id }
                    $imported = 0
                    foreach ($entry in $importData.TimeEntries) {
                        if ($entry.Id -notin $existingIds) {
                            $script:Data.TimeEntries += $entry
                            $imported++
                        }
                    }
                    Write-Success "Imported $imported new time entries"
                }
                
                Save-UnifiedData
                Write-Success "Data merge complete!"
            }
            "2" {
                Write-Warning "Replace all data? Type 'yes' to confirm"
                $confirm = Read-Host
                if ($confirm -eq 'yes') {
                    $script:Data = $importData
                    Save-UnifiedData
                    Write-Success "Data replaced successfully!"
                }
            }
            "3" {
                Write-Info "Import cancelled"
            }
        }
    } catch {
        Write-Error "Import failed: $_"
    }
}

#endregion

#region Reset Functions

function Reset-ToDefaults {
    Write-Header "Reset to Defaults"
    
    Write-Warning "This will reset all settings to defaults. Data will be preserved."
    Write-Host "Type 'yes' to confirm:"
    $confirm = Read-Host
    
    if ($confirm -eq 'yes') {
        # Backup first
        Backup-Data -Silent
        
        # Reset settings while preserving data
        $script:Data.Settings = Get-DefaultSettings
        
        Save-UnifiedData
        Initialize-ThemeSystem
        
        Write-Success "Settings reset to defaults!"
    }
}

#endregion

#region Clipboard Functions

function Copy-ToClipboard {
    param([string]$Text)
    
    try {
        $Text | Set-Clipboard
        return $true
    } catch {
        Write-Warning "Could not copy to clipboard: $_"
        return $false
    }
}

function Get-FromClipboard {
    try {
        return Get-Clipboard
    } catch {
        Write-Warning "Could not read from clipboard: $_"
        return $null
    }
}

#endregion
# main.ps1
# (Based on main-ps1.txt, updated for modularization and new features)

# Unified Productivity Suite v5.0 - Main Entry Point
# PowerShell 7.2+ Recommended for PSStyle, 5.1+ Core Functionality

#region Module Loading

# Get script directory
$script:ModuleRoot = $PSScriptRoot

# Dot source modules in dependency order
. "$script:ModuleRoot\helper.ps1" # Load helper first for Save/Load data and other utils
. "$script:ModuleRoot\theme.ps1"
. "$script:ModuleRoot\ui.ps1" # Depends on theme
. "$script:ModuleRoot\core-data.ps1" # Data structures, project/task/snippet logic
. "$script:ModuleRoot\core-time.ps1" # Time tracking, time reports

# Initialize systems
# Data model is initialized within core-data.ps1 itself when it's sourced.
Load-UnifiedData # From helper.ps1 - populates $script:Data
Initialize-ThemeSystem # From theme.ps1 - uses $script:Data.Settings.Theme

#endregion

#region Quick Action System (Requirement H)

# Quick action map for +key shortcuts
# Actions now call functions from their respective modules
$script:QuickActionMap = @{
    # Time actions
    '9' = { Add-ManualTimeEntry; return $true } # core-time.ps1
    'm' = { Add-ManualTimeEntry; return $true } # core-time.ps1
    'time' = { Add-ManualTimeEntry; return $true } # core-time.ps1
    's' = { Start-Timer; return $true }         # core-time.ps1
    'timer' = { Start-Timer; return $true }     # core-time.ps1
    'stop' = { Stop-Timer; return $true }       # core-time.ps1
    
    # Task actions
    'a' = { Add-TodoTask; return $true }        # core-data.ps1
    'task' = { Add-TodoTask; return $true }     # core-data.ps1
    'qa' = {                                    # core-data.ps1
        $qaInput = Read-Host "Quick add task details"
        Quick-AddTask -Input $qaInput 
        return $true
    }
    
    # View actions
    'v' = {                                     # core-time.ps1 (Show-ActiveTimers) -> ui.ps1
        Show-ActiveTimers # This function will be in ui.ps1, using data from core-time
        Write-Host "`nPress any key to continue..."
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        return $true
    }
    't' = { Show-TaskManagementMenu; return $true } # main.ps1 (orchestrates task views from ui.ps1)
    'today' = { Show-TodayView; return $true } # ui.ps1
    'w' = {                                     # main.ps1 (orchestrates report from core-time.ps1 and ui.ps1)
        Display-WeekReport # New wrapper in main.ps1
        Write-Host "`nPress Enter to continue..."
        Read-Host
        return $true
    }
    'week' = $script:QuickActionMap['w'] # Alias
    
    # Project actions
    'p' = {                                     # core-data.ps1 (Show-ProjectDetail data) -> ui.ps1
        Show-ProjectDetail # This function will be in ui.ps1, using data from core-data
        Write-Host "`nPress Enter to continue..."
        Read-Host
        return $true
    }
    'projects' = { Show-ProjectsMenu; return $true } # main.ps1
    
    # Command snippets (Requirement D related)
    'c' = { Manage-CommandSnippets; return $true }  # core-data.ps1
    'cmd' = $script:QuickActionMap['c'] # Alias
    'snippets' = $script:QuickActionMap['c'] # Alias
    
    # Reports
    'r' = { Show-ReportsMenu; return $true }       # main.ps1
    'export' = { Export-FormattedTimesheet; return $true } # core-time.ps1 (Requirement I)
    'timesheet' = $script:QuickActionMap['export'] # Alias
    
    # Calendar
    'cal' = { Show-Calendar; return $true } # ui.ps1

    # Help
    'h' = { Show-Help; return $true }           # ui.ps1
    'help' = $script:QuickActionMap['h'] # Alias
    '?' = { Show-QuickActionHelp; return $true }# main.ps1
}

function Process-QuickAction { # From main-ps1.txt
    param([string]$Key)
    $actionKey = $Key.ToLower()
    $action = $script:QuickActionMap[$actionKey]
    if ($action) {
        return & $action
    }
    $matches = $script:QuickActionMap.Keys | Where-Object { $_.StartsWith($actionKey) }
    if ($matches.Count -eq 1) {
        $action = $script:QuickActionMap[$matches[0]]
        return & $action
    } elseif ($matches.Count -gt 1) {
        Write-Warning "Ambiguous quick action '+$($Key)'. Matches: $($matches -join ', ')"
        return $true # Indicate action was handled (by showing warning)
    }
    return $false # No action found
}

function Show-QuickActionHelp { # From main-ps1.txt, updated for new actions
    Write-Header "Quick Actions Help (+Key)" # ui.ps1
    Write-Host "Use +key from any prompt to trigger quick actions:" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    # Content matches Show-Help from ui.ps1 for consistency
    Show-Help # ui.ps1's Show-Help already has a good quick actions list
}

#endregion

#region Menu Structure & Handling

$script:MenuStructure = @{
    "1" = @{Label="Time Management"; Action={ Show-TimeManagementMenu }}
    "2" = @{Label="Task Management"; Action={ Show-TaskManagementMenu }}
    "3" = @{Label="Reports & Analytics"; Action={ Show-ReportsMenu }}
    "4" = @{Label="Projects & Clients"; Action={ Show-ProjectsMenu }}
    "5" = @{Label="Tools & Utilities"; Action={ Show-ToolsMenu }}
    "6" = @{Label="Settings & Config"; Action={ Show-SettingsMenu }}
}

function Show-GenericMenu {
    param(
        [string]$MenuTitle,
        [ordered]@{Key=[string];Label=[string];Action=[scriptblock]} $MenuOptions, # Ordered hashtable for predictable display
        [switch]$ShowBackButton = $true
    )
    while ($true) {
        Write-Header $MenuTitle # ui.ps1
        foreach ($key in $MenuOptions.Keys) {
            Write-Host "  [$key] $($MenuOptions[$key].Label)"
        }
        if ($ShowBackButton) { Write-Host "`n  [B] Back" }
        
        $choice = Read-Host "`nChoice"
        if ($ShowBackButton -and $choice.ToUpper() -eq 'B') { return }

        if ($MenuOptions.ContainsKey($choice.ToUpper())) {
            Clear-Host # Clear before executing action for cleaner screen
            & $MenuOptions[$choice.ToUpper()].Action
            if ($ShowBackButton) { # Only pause if not returning immediately (like 'B')
                Write-Host "`nPress Enter to return to '$MenuTitle' menu..." ; Read-Host | Out-Null
            }
        } elseif (-not [string]::IsNullOrWhiteSpace($choice)) {
            Write-Warning "Invalid choice." ; Start-Sleep -Seconds 1
        }
    }
}

function Show-TimeManagementMenu {
    $options = [ordered]@{
        "1" = @{Label="Manual Time Entry (Preferred)"; Action={ Add-ManualTimeEntry }} # core-time.ps1
        "2" = @{Label="Start Timer"; Action={ Start-Timer }} # core-time.ps1
        "3" = @{Label="Stop Timer"; Action={ Stop-Timer }} # core-time.ps1
        "4" = @{Label="View Active Timers"; Action={ Show-ActiveTimers }} # ui.ps1 (uses core-time data)
        "5" = @{Label="Quick Time Entry (PROJECT HR [DESC])"; Action={ $input = Read-Host "Entry"; Quick-TimeEntry $input }} # core-time.ps1
        "6" = @{Label="Edit Time Entry"; Action={ Edit-TimeEntry }} # core-time.ps1
        "7" = @{Label="Delete Time Entry"; Action={ Delete-TimeEntry }} # core-time.ps1
        "8" = @{Label="Today's Time Log"; Action={ Display-TodayTimeLog }} # main.ps1 (UI wrapper)
        "9" = @{Label="Export Formatted Timesheet"; Action={ Export-FormattedTimesheet }} # core-time.ps1
    }
    Show-GenericMenu -MenuTitle "Time Management" -MenuOptions $options
}

function Show-TaskManagementMenu { # Adapted from Pmc Mod Base
    $filter = ""; $sortBy = "Smart"; $showCompleted = $false; $viewMode = "Default"
    while ($true) {
        Clear-Host; Write-Header "Task Management" # ui.ps1
        Show-TasksView -Filter $filter -SortBy $sortBy -ShowCompleted:$showCompleted -View $viewMode # ui.ps1
        
        $statusLine = "Filter: $(if ($filter){"'$filter'"}else{"None"}) | Sort: $sortBy | View: $viewMode | Showing: $(if($showCompleted){'All'}else{'Active'})"
        Write-Host "`n$statusLine" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
        Write-Host "Commands: [A]dd, [C]omplete, [E]dit, [D]elete, [P]rogress, [ST]Subtasks"
        Write-Host "Display:  [F]ilter, [S]ort, [V]iewMode, [T]oggleCompleted"
        Write-Host "Archive:  View A[R]chive, [AR]chive Old Tasks"
        Write-Host "Shortcuts: 'c <id>', 'e <id>', 'd <id>', 'p <id>'"
        Write-Host "[B]ack"
        $choice = Read-Host "`nTask Command"

        if ($choice -match '^([cdepst])\s+(.+)$' -and $Matches[1].ToLower() -ne 's') { # 's' is for Sort command
            $cmd = $Matches[1].ToLower(); $id = $Matches[2]
            switch ($cmd) {
                "c" { Complete-Task -TaskId $id } # core-data
                "d" { Remove-Task -TaskId $id }   # core-data
                "e" { Edit-Task -TaskId $id }     # core-data
                "p" { Update-TaskProgress -TaskId $id } # core-data
                "st" { Manage-Subtasks -TaskId $id } # core-data
            }
            continue # Loop back after action
        }
        switch ($choice.ToLower()) {
            "a"  { Add-TodoTask } # core-data
            "c"  { $id = Read-Host "ID to complete"; Complete-Task -TaskId $id }
            "e"  { $id = Read-Host "ID to edit"; Edit-Task -TaskId $id }
            "d"  { $id = Read-Host "ID to delete"; Remove-Task -TaskId $id }
            "p"  { $id = Read-Host "ID to update progress"; Update-TaskProgress -TaskId $id }
            "st" { $id = Read-Host "ID to manage subtasks"; Manage-Subtasks -TaskId $id }
            "f"  { $filter = Read-Host "Filter text (blank for none)" }
            "s"  { $sortBy = (Show-MenuSelection -Title "Sort By" -Options @("Smart","Priority","DueDate","Created","Category","Project") -Prompt "Sort choice"); if(-not $sortBy){$sortBy="Smart"} }
            "v"  { $viewMode = (Show-MenuSelection -Title "View Mode" -Options @("Default","Kanban","Timeline","Project") -Prompt "View choice"); if(-not $viewMode){$viewMode="Default"} }
            "t"  { $showCompleted = -not $showCompleted; Write-Info "Show completed toggled to $showCompleted" }
            "r"  { View-TaskArchive } # core-data (placeholder) -> ui.ps1 to display
            "ar" { Archive-CompletedTasks } # core-data
            "b"  { return }
            default { if($choice){Write-Warning "Unknown task command." ; Start-Sleep 1} }
        }
    }
}

function Show-ReportsMenu {
    $options = [ordered]@{
        "1" = @{Label="Week Report (Summary)"; Action={ Display-WeekReport }} # main.ps1 UI wrapper
        "2" = @{Label="Extended Week Report (Detailed)"; Action={ Display-ExtendedReport }} # main.ps1 UI wrapper
        "3" = @{Label="Month Summary"; Action={ Display-MonthSummary }} # main.ps1 UI wrapper
        "4" = @{Label="Project Summary"; Action={ Display-ProjectSummary }} # main.ps1 UI wrapper
        "5" = @{Label="Task Analytics"; Action={ Display-TaskAnalytics }} # main.ps1 UI wrapper
        "6" = @{Label="Time Analytics"; Action={ Display-TimeAnalytics }} # main.ps1 UI wrapper
        "7" = @{Label="Export Formatted Timesheet"; Action={ Export-FormattedTimesheet }} # core-time.ps1
        "8" = @{Label="Export ALL Data (JSON & CSVs)"; Action={ Export-AllData }} # helper.ps1
        "9" = @{Label="Change Report Week"; Action={ Change-ReportWeek }} # main.ps1
    }
    Show-GenericMenu -MenuTitle "Reports & Analytics" -MenuOptions $options
}

function Show-ProjectsMenu {
    $options = [ordered]@{
        "1" = @{Label="View Projects & Templates"; Action={ Show-ProjectsAndTemplates -Simple:$false }} # ui.ps1
        "2" = @{Label="Add New Project"; Action={ Add-Project }} # core-data.ps1
        "3" = @{Label="Edit Project"; Action={ Show-ProjectsAndTemplates -Simple; Edit-Project }} # ui.ps1, core-data.ps1
        "4" = @{Label="View Project Details"; Action={ Show-ProjectsAndTemplates -Simple; Show-ProjectDetail }} # ui.ps1, core-data.ps1 (for data)
        "5" = @{Label="Import Project from Excel Form"; Action={ Import-ProjectFromExcel }} # core-data.ps1
        "6" = @{Label="Batch Import Projects (Future)"; Action={ Batch-ImportProjects }} # core-data.ps1
        "7" = @{Label="Export Projects to CSV"; Action={ Export-Projects }} # core-data.ps1
    }
    Show-GenericMenu -MenuTitle "Projects & Clients" -MenuOptions $options
}

function Show-ToolsMenu {
     $options = [ordered]@{
        "1" = @{Label="Command Snippets"; Action={ Manage-CommandSnippets }} # core-data.ps1
        "2" = @{Label="Calendar"; Action={ Show-Calendar }} # ui.ps1
        "3" = @{Label="Excel Copy Jobs"; Action={ Show-ExcelCopyJobsMenu }} # main.ps1
        "4" = @{Label="Quick Actions Help"; Action={ Show-QuickActionHelp }} # main.ps1
        "5" = @{Label="Backup Current Data"; Action={ Backup-Data; Write-Info "Backup initiated." }} # helper.ps1
        "6" = @{Label="Test Excel COM Connection"; Action={ Test-ExcelConnection }} # helper.ps1
    }
    Show-GenericMenu -MenuTitle "Tools & Utilities" -MenuOptions $options
}

function Show-ExcelCopyJobsMenu {
    $options = [ordered]@{
        "1" = @{Label="Create New Excel Copy Job"; Action={ New-ExcelCopyJob }} # core-data.ps1
        "2" = @{Label="Execute Excel Copy Job"; Action={ Execute-ExcelCopyJob }} # core-data.ps1
        "3" = @{Label="Edit Excel Copy Job (Placeholder)"; Action={ Edit-ExcelCopyJob }} # core-data.ps1
        "4" = @{Label="Remove Excel Copy Job"; Action={ Remove-ExcelCopyJob }} # core-data.ps1
    }
    Show-GenericMenu -MenuTitle "Excel Copy Jobs" -MenuOptions $options
}

function Show-SettingsMenu {
    $options = [ordered]@{
        "1" = @{Label="Time Tracking Settings"; Action={ Edit-TimeTrackingSettings }} # core-time.ps1
        "2" = @{Label="Task Management Settings"; Action={ Edit-TaskSettings }} # core-data.ps1
        "3" = @{Label="Command Snippet Settings"; Action={ Edit-CommandSnippetSettings }} # core-data.ps1
        "4" = @{Label="Excel Form Mapping Config"; Action={ Configure-ExcelForm }} # core-data.ps1
        "5" = @{Label="Theme Settings (Legacy Console)"; Action={ Edit-ThemeSettings }} # theme.ps1
        "6" = @{Label="Backup Data"; Action={ Backup-Data }} # helper.ps1
        "7" = @{Label="Restore from Backup"; Action={ Restore-FromBackup }} # helper.ps1
        "8" = @{Label="Export ALL Data"; Action={ Export-AllData }} # helper.ps1
        "9" = @{Label="Import Data (from JSON backup)"; Action={ Import-Data }} # helper.ps1 (needs defining in helper)
        "R" = @{Label="Reset All Settings to Defaults"; Action={ Reset-ToDefaults }} # helper.ps1 (needs defining in helper)
    }
    Show-CurrentSettings # Display current settings overview
    Show-GenericMenu -MenuTitle "Settings & Configuration" -MenuOptions $options
}

#endregion

#region Main Loop & UI Wrappers for Reports

function Show-MainMenu { # Adapted from main-ps1.txt
    while ($true) {
        Show-Dashboard # ui.ps1
        Write-Host "`nCommand: " -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
        $inputChoice = Read-Host
        
        if ([string]::IsNullOrWhiteSpace($inputChoice)) { continue }

        if ($inputChoice.StartsWith("+")) {
            if (Process-QuickAction $inputChoice.Substring(1)) { continue }
            else { Write-Warning "Unknown quick action: $inputChoice. Use +? for help."; Start-Sleep 1; continue }
        }
        
        # Direct dashboard shortcuts
        $dashboardActions = @{
            "M" = { Add-ManualTimeEntry }
            "S" = { Start-Timer }
            "A" = { Add-TodoTask }
            "V" = { Show-ActiveTimers; Write-Host "`nPress key..."; $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown") }
            "T" = { Show-TodayView }
            "W" = { Display-WeekReport; Write-Host "`nPress key..."; Read-Host | Out-Null }
            "P" = { Show-ProjectDetail; Write-Host "`nPress key..."; Read-Host | Out-Null }
            "H" = { Show-Help }
            "C" = { Manage-CommandSnippets } # Direct shortcut for snippets
        }

        if ($dashboardActions.ContainsKey($inputChoice.ToUpper())) {
            & $dashboardActions[$inputChoice.ToUpper()]
            continue
        }

        if ($script:MenuStructure.ContainsKey($inputChoice.ToUpper())) {
            & $script:MenuStructure[$inputChoice.ToUpper()].Action
        } elseif ($inputChoice.ToUpper() -eq 'Q') {
            if ($script:Data.ActiveTimers.Count -gt 0) {
                Write-Warning "You have $($script:Data.ActiveTimers.Count) active timer(s)! Stop all before quitting? (Y/N)"
                if ((Read-Host).ToUpper() -eq 'Y') { Stop-Timer -TimerKeyToStop 'all' } # core-time.ps1
            }
            Save-UnifiedData # helper.ps1
            Write-Host "`n👋 Thanks for using Unified Productivity Suite! Stay productive! 🚀" -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
            return
        } else {
            # Fallback for quick entry commands from dashboard not starting with +
            if ($inputChoice -match '^q\s+(.+)') { Quick-TimeEntry $inputChoice.Substring(2).Trim() } # core-time
            elseif ($inputChoice -match '^qa\s+(.+)') { Quick-AddTask -Input $inputChoice.Substring(3).Trim() } # core-data
            else { Write-Warning "Unknown command. Use numbers for menu, +key for quick actions, or [H] for help."; Start-Sleep 1 }
        }
    }
}

# UI Wrappers for Reports (call data functions from core-time, display using ui.ps1)
function Display-WeekReport {
    Write-Header "Week Report"
    $reportData = Get-WeekReportData # core-time.ps1
    if (-not $reportData) { Write-Info "No data for this week."; return }
    
    $columns = @(
        @{Name="Name"; Title="Project"; Width=25; Wrap=$true},
        @{Name="Id1"; Title="ID1"; Width=10},
        @{Name="Id2"; Title="ID2"; Width=10},
        @{Name="Mon"; Title="Mon"; Width=6; Align="Right"},
        @{Name="Tue"; Title="Tue"; Width=6; Align="Right"},
        @{Name="Wed"; Title="Wed"; Width=6; Align="Right"},
        @{Name="Thu"; Title="Thu"; Width=6; Align="Right"},
        @{Name="Fri"; Title="Fri"; Width=6; Align="Right"},
        @{Name="Total"; Title="Total"; Width=7; Align="Right"},
        @{Name="Value"; Title="Value ($)"; Width=10; Align="Right"}
    )
    Format-TableUnicode -Data $reportData -Columns $columns -Title "Week of $(($script:Data.CurrentWeek).ToString('yyyy-MM-dd'))"
    # Overall totals
    $grandTotal = ($reportData | Measure-Object -Property Total -Sum).Sum
    $grandValue = ($reportData | Measure-Object -Property Value -Sum).Sum
    Write-Host "Overall Total Hours: $([Math]::Round($grandTotal,2))" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
    Write-Host "Overall Billable Value: $($(Get-ThemeProperty "Palette.CurrencySymbol"))$([Math]::Round($grandValue,2))" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
}

function Display-ExtendedReport {
    Write-Header "Extended Week Report"
    $entries = Get-ExtendedReportData # core-time.ps1
    if ($entries.Count -eq 0) { Write-Info "No entries for this week."; return }
    
    # Group by date for display
    $groupedByDate = $entries | Group-Object Date | Sort-Object Name
    foreach ($dateGroup in $groupedByDate) {
        $date = [datetime]::Parse($dateGroup.Name)
        Write-Host "`n📅 $($date.ToString('dddd, MMM dd yyyy'))" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
        $dayData = $dateGroup.Group | ForEach-Object {
            $project = Get-ProjectOrTemplate $_.ProjectKey
            $taskDesc = if ($_.TaskId) { ($script:Data.Tasks | Where-Object Id -eq $_.TaskId).Description } else { $_.Description }
            [PSCustomObject]@{
                Time = if ($_.StartTime -and $_.EndTime) { "$($_.StartTime)-$($_.EndTime)" } else { "[Manual]" }
                Hours = "$($_.Hours)h"
                Project = $project.Name
                Details = $taskDesc
            }
        }
        Format-TableUnicode -Data $dayData -NoHeader -BorderStyle "Rounded" -Columns @(
            @{Name="Time"; Width=12}, @{Name="Hours"; Width=7; Align="Right"},
            @{Name="Project"; Width=20}, @{Name="Details"; Width=35; Wrap=$true}
        )
    }
}

function Display-TodayTimeLog {
    Write-Header "Today's Time Log"
    $entries = Get-TodayTimeLogData # core-time.ps1
    if ($entries.Count -eq 0) { Write-Info "No time logged today yet."; return }
    # Display logic similar to Display-ExtendedReport for one day
    $todayData = $entries | ForEach-Object {
        $project = Get-ProjectOrTemplate $_.ProjectKey
        $taskDesc = if ($_.TaskId) { ($script:Data.Tasks | Where-Object Id -eq $_.TaskId).Description } else { $_.Description }
        [PSCustomObject]@{
            Time = if ($_.StartTime -and $_.EndTime) { "$($_.StartTime)-$($_.EndTime)" } else { "[Manual]" }
            Hours = "$($_.Hours)h"
            Project = $project.Name
            Details = $taskDesc
        }
    }
    Format-TableUnicode -Data $todayData -Title "Entries for $((Get-Date).ToString('MMM dd, yyyy'))" -Columns @(
        @{Name="Time"; Width=12}, @{Name="Hours"; Width=7; Align="Right"},
        @{Name="Project"; Width=25}, @{Name="Details"; Width=40; Wrap=$true}
    )
    $totalHours = ($entries | Measure-Object Hours -Sum).Sum
    Write-Host "Total Hours Today: $([Math]::Round($totalHours,2))" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
}

function Display-MonthSummary {
    Write-Header "Month Summary for $((Get-Date $script:Data.CurrentWeek).ToString('MMMM yyyy'))"
    $monthEntries = Get-MonthSummaryData -MonthDate $script:Data.CurrentWeek # core-time
    if ($monthEntries.Count -eq 0) { Write-Info "No entries for this month."; return }

    $byProject = $monthEntries | Group-Object ProjectKey | ForEach-Object {
        $project = Get-ProjectOrTemplate $_.Name
        $hours = ($_.Group | Measure-Object -Property Hours -Sum).Sum
        [PSCustomObject]@{
            Project = $project.Name
            Client = $project.Client
            Hours = [Math]::Round($hours, 2)
            Value = if ($project.BillingType -eq "Billable") { [Math]::Round($hours * $project.Rate, 2) } else { 0 }
        }
    } | Sort-Object Hours -Descending
    
    Format-TableUnicode -Data $byProject -Columns @(
        @{Name="Project"; Width=30}, @{Name="Client"; Width=20},
        @{Name="Hours"; Width=10; Align="Right"}, @{Name="Value"; Title="Value ($)"; Width=12; Align="Right"}
    )
    $totalHours = ($byProject | Measure-Object Hours -Sum).Sum
    $totalValue = ($byProject | Measure-Object Value -Sum).Sum
    Write-Host "Month Total Hours: $([Math]::Round($totalHours,2))" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
    Write-Host "Month Billable Value: $($(Get-ThemeProperty "Palette.CurrencySymbol"))$([Math]::Round($totalValue,2))" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
}

function Display-ProjectSummary {
    Write-Header "All Projects Summary"
    $projects = Get-ProjectSummaryData # core-time.ps1 (gets projects with updated stats)
    if ($projects.Count -eq 0) { Write-Info "No projects found."; return }
    $summaryData = $projects | ForEach-Object {
        Update-ProjectStatistics -ProjectKey $_.Key # Ensure stats are fresh
        [PSCustomObject]@{
            Key = $_.Key; Name = $_.Name; Status = $_.Status; Client = $_.Client
            TotalHours = $_.TotalHours; Budget = $_.Budget
            BudgetUsed = if ($_.Budget -gt 0) { [Math]::Round(($_.TotalHours / $_.Budget)*100,0).ToString() + "%" } else {"N/A"}
            ActiveTasks = $_.ActiveTasks; CompletedTasks = $_.CompletedTasks
        }
    } | Sort-Object Status, Name
    Format-TableUnicode -Data $summaryData -Columns @(
        @{Name="Key"; Width=10}, @{Name="Name"; Width=25}, @{Name="Status"; Width=10}, @{Name="Client"; Width=15},
        @{Name="TotalHours";Title="Hours"; Width=7;Align="Right"}, @{Name="BudgetUsed";Title="Budget%";Width=10;Align="Right"},
        @{Name="ActiveTasks";Title="ActiveT";Width=8;Align="Right"}
    )
}

function Display-TaskAnalytics {
    Write-Header "Task Analytics"
    # This would call data aggregation functions from core-data.ps1 if complex,
    # or perform simple aggregations here for display.
    # Example:
    $allTasks = $script:Data.Tasks | Where-Object { $_.IsCommand -ne $true }
    if ($allTasks.Count -eq 0) { Write-Info "No tasks to analyze."; return }
    # ... (detailed analytics like in Pmc Mod Base's Show-TaskAnalytics)
    Write-Warning "Task Analytics display is simplified. Full stats in Pmc Mod Base."
    Show-TaskStatistics $allTasks # ui.ps1 (provides a good summary)
}

function Display-TimeAnalytics {
    Write-Header "Time Analytics"
    $analyticsData = Get-TimeAnalyticsData # core-time.ps1
    # ... (display logic for stats by day of week, top projects, etc.) ...
    Write-Warning "Time Analytics display is simplified. Full stats in Pmc Mod Base."
    Write-Host "Total hours in last 30 days: $(($analyticsData.Last30DaysEntries | Measure-Object Hours -Sum).Sum)"
}

function Change-ReportWeek { # From main-ps1.txt
    Write-Host "[P]revious, [N]ext, [T]oday's week, or enter date (YYYY-MM-DD): " -NoNewline
    $nav = Read-Host
    $currentReportWeek = Get-WeekStart $script:Data.CurrentWeek # Ensure it's always a Monday

    switch ($nav.ToUpper()) {
        'P' { $script:Data.CurrentWeek = $currentReportWeek.AddDays(-7) }
        'N' { $script:Data.CurrentWeek = $currentReportWeek.AddDays(7) }
        'T' { $script:Data.CurrentWeek = Get-WeekStart (Get-Date) } # helper.ps1
        default {
            try { $script:Data.CurrentWeek = Get-WeekStart ([DateTime]::Parse($nav)) }
            catch { Write-Error "Invalid date format. Report week unchanged."; return }
        }
    }
    Save-UnifiedData # helper.ps1
    Write-Success "Report week changed to start: $($script:Data.CurrentWeek.ToString('yyyy-MM-dd'))"
}

function Show-CurrentSettings { # From main-ps1.txt, shows overview before settings menu
    Write-Header "Current Settings Overview"
    $s = $script:Data.Settings
    $cs = $s.CommandSnippets
    $theme = $s.Theme
    $data = @(
        [PSCustomObject]@{Setting="Default Rate"; Value="$($s.DefaultRate)/hr ($($s.Currency))"}
        [PSCustomObject]@{Setting="Work Schedule"; Value="$($s.HoursPerDay) hrs/day, $($s.DaysPerWeek) days/wk"}
        [PSCustomObject]@{Setting="Task Default Priority"; Value=$s.DefaultPriority}
        [PSCustomObject]@{Setting="Task Default Category"; Value=$s.DefaultCategory}
        [PSCustomObject]@{Setting="Show Completed Tasks (days)"; Value=$s.ShowCompletedDays}
        [PSCustomObject]@{Setting="Auto-Archive Tasks (days)"; Value=$s.AutoArchiveDays}
        [PSCustomObject]@{Setting="Snippet Hotkeys Enabled"; Value=$cs.EnableHotkeys}
        [PSCustomObject]@{Setting="Snippet Auto-Copy"; Value=$cs.AutoCopyToClipboard}
        [PSCustomObject]@{Setting="Theme Header Color"; Value="$($theme.Header) (Legacy)"}
    )
    Format-TableUnicode -Data $data -NoHeader -BorderStyle "None" -Columns @(
        @{Name="Setting";Width=35}, @{Name="Value";Width=35}
    )
}

#endregion

#region Entry Point

function Start-UnifiedProductivitySuite {
    Write-Host "Unified Productivity Suite v5.0" -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
    Write-Host "Initializing..." -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    
    if (-not $script:Data.Settings.QuickActionTipShown) {
        Write-Host "`n✨ TIP: Use +key shortcuts (e.g., +a, +time, +?) for quick access!" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
        $script:Data.Settings.QuickActionTipShown = $true
        Save-UnifiedData
        Start-Sleep -Seconds 2
    }
    
    Show-MainMenu
}

Start-UnifiedProductivitySuite
#endregion
# theme.ps1
# (Content from theme-ps1.txt - Assumed correct and complete for this phase)

# Theme System Module
# Handles colors, styles, and visual presentation

#region Border Styles

$Global:borderStyles = @{
    None = @{
        TopLeft     = " "
        TopRight    = " "
        BottomLeft  = " "
        BottomRight = " "
        Horizontal  = " "
        Vertical    = " "
        Cross       = " "
        TLeft       = " "
        TRight      = " "
        TTop        = " "
        TBottom     = " "
    }
    Single = @{
        TopLeft     = "┌"
        TopRight    = "┐"
        BottomLeft  = "└"
        BottomRight = "┘"
        Horizontal  = "─"
        Vertical    = "│"
        Cross       = "┼"
        TLeft       = "├"
        TRight      = "┤"
        TTop        = "┬"
        TBottom     = "┴"
    }
    Double = @{
        TopLeft     = "╔"
        TopRight    = "╗"
        BottomLeft  = "╚"
        BottomRight = "╝"
        Horizontal  = "═"
        Vertical    = "║"
        Cross       = "╬"
        TLeft       = "╠"
        TRight      = "╣"
        TTop        = "╦"
        TBottom     = "╩"
    }
    Rounded = @{
        TopLeft     = "╭"
        TopRight    = "╮"
        BottomLeft  = "╰"
        BottomRight = "╯"
        Horizontal  = "─"
        Vertical    = "│"
        Cross       = "┼"
        TLeft       = "├"
        TRight      = "┤"
        TTop        = "┬"
        TBottom     = "┴"
    }
    Heavy = @{
        TopLeft     = "┏"
        TopRight    = "┓"
        BottomLeft  = "┗"
        BottomRight = "┛"
        Horizontal  = "━"
        Vertical    = "┃"
        Cross       = "╋"
        TLeft       = "┣"
        TRight      = "┫"
        TTop        = "┳"
        TBottom     = "┻"
    }
}

#endregion

#region Theme Management

# Default theme structure
$script:DefaultTheme = @{
    Name = "Default"
    Description = "Clean default theme"
    Palette = @{
        PrimaryFG = "#FFFFFF"
        SecondaryFG = "#808080"
        AccentFG = "#00D7FF"
        SuccessFG = "#5FFF87"
        ErrorFG = "#FF005F"
        WarningFG = "#FFFF00"
        InfoFG = "#5FD7FF"
        HeaderFG = "#00D7FF" # Default from theme.ps1, may be overridden by legacy
        SubtleFG = "#808080" # Default from theme.ps1, may be overridden by legacy
    }
    DataTable = @{
        BorderStyle = "Single"
        BorderFG = "#FFFFFF" # Default from theme.ps1
        Pad = 1
        Header = @{
            FG = "#00D7FF" # Default from theme.ps1
            BG = $null
            Separator = $true
            Case = "Default"
        }
        DataRow = @{
            FG = "#FFFFFF" # Default from theme.ps1
            BG = $null
        }
        AltRow = @{
            FG = "#808080" # Default from theme.ps1
            BG = $null
        }
        Highlight = @{
            Overdue = @{FG = "#FF005F"} # Default from theme.ps1
            DueSoon = @{FG = "#FFFF00"} # Default from theme.ps1
            Completed = @{FG = "#808080"} # Default from theme.ps1
            Selected = @{FG = "#000000"; BG = "#00D7FF"} # Default from theme.ps1
        }
    }
}

# Current theme storage
$script:CurrentTheme = $null

function Initialize-ThemeSystem {
    # Load theme from settings or use default
    # Prioritizing legacy settings if they exist, then $script:DefaultTheme
    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.Theme -is [hashtable]) {
        $legacyTheme = $script:Data.Settings.Theme
        $script:CurrentTheme = $script:DefaultTheme # Start with default structure

        $script:CurrentTheme.Name = "LegacyAdapt"
        $script:CurrentTheme.Description = "Adapted from legacy settings"
        
        # Palette mapping from legacy console colors to hex
        $script:CurrentTheme.Palette.AccentFG = $(Get-ConsoleColorHex $legacyTheme.Accent)
        $script:CurrentTheme.Palette.SuccessFG = $(Get-ConsoleColorHex $legacyTheme.Success)
        $script:CurrentTheme.Palette.ErrorFG = $(Get-ConsoleColorHex $legacyTheme.Error)
        $script:CurrentTheme.Palette.WarningFG = $(Get-ConsoleColorHex $legacyTheme.Warning)
        $script:CurrentTheme.Palette.InfoFG = $(Get-ConsoleColorHex $legacyTheme.Info)
        $script:CurrentTheme.Palette.HeaderFG = $(Get-ConsoleColorHex $legacyTheme.Header)
        $script:CurrentTheme.Palette.SubtleFG = $(Get-ConsoleColorHex $legacyTheme.Subtle)
        
        # DataTable settings from DefaultTheme are kept unless explicitly overridden by legacy if we add more.
        # For now, this primarily impacts Palette colors used by DataTable.
        $script:CurrentTheme.DataTable.Header.FG = $script:CurrentTheme.Palette.HeaderFG
        # Potentially other DataTable direct color settings if legacy theme had them

    } else {
        $script:CurrentTheme = $script:DefaultTheme
    }
}

function Get-ConsoleColorHex {
    param($ColorName)
    
    # If $ColorName is already a hex value, return it.
    if ($ColorName -match '^#[0-9A-Fa-f]{6}$') {
        return $ColorName
    }

    $colorMap = @{
        "Black" = "#000000"
        "DarkBlue" = "#000080"
        "DarkGreen" = "#008000"
        "DarkCyan" = "#008080"
        "DarkRed" = "#800000"
        "DarkMagenta" = "#800080"
        "DarkYellow" = "#808000" # Brown
        "Gray" = "#C0C0C0"      # Light Gray
        "DarkGray" = "#808080"
        "Blue" = "#0000FF"
        "Green" = "#00FF00"
        "Cyan" = "#00FFFF"
        "Red" = "#FF0000"
        "Magenta" = "#FF00FF"
        "Yellow" = "#FFFF00"
        "White" = "#FFFFFF"
    }
    
    if ($colorMap.ContainsKey($ColorName)) {
        return $colorMap[$ColorName]
    }
    # Fallback if color name is not found, or if it's an invalid hex
    return "#FFFFFF" # Default to white
}

function Get-BorderStyleChars {
    param(
        [string]$Style = "Single"
    )
    
    if ($Global:borderStyles.ContainsKey($Style)) {
        return $Global:borderStyles[$Style]
    }
    return $Global:borderStyles.Single # Fallback
}

function Get-ThemeProperty {
    param(
        [string]$Path # e.g., "Palette.AccentFG" or "DataTable.Header.FG"
    )
    
    $parts = $Path -split '\.'
    $current = $script:CurrentTheme
    
    foreach ($part in $parts) {
        if ($current -is [hashtable] -and $current.ContainsKey($part)) {
            $current = $current[$part]
        } elseif ($current -is [PSCustomObject] -and $current.PSObject.Properties[$part]) {
            $current = $current.$part
        }
        else {
            # Fallback to default theme if property not found in current
            $defaultCurrent = $script:DefaultTheme
            foreach ($defaultPart in $parts) { # Re-traverse path in default theme
                if ($defaultCurrent -is [hashtable] -and $defaultCurrent.ContainsKey($defaultPart)) {
                    $defaultCurrent = $defaultCurrent[$defaultPart]
                } elseif ($defaultCurrent -is [PSCustomObject] -and $defaultCurrent.PSObject.Properties[$defaultPart]) {
                    $defaultCurrent = $defaultCurrent.$defaultPart
                } else {
                    return $null # Property not found in default theme either
                }
            }
            return $defaultCurrent
        }
    }
    
    # Handle palette references like "$Palette:PrimaryFG"
    if ($current -is [string] -and $current.StartsWith('$Palette:')) {
        $paletteKey = $current.Substring('$Palette:'.Length)
        return Get-ThemeProperty "Palette.$paletteKey"
    }

    return $current
}

#endregion

#region PSStyle Support

function Get-PSStyleValue {
    param(
        [string]$FG, # Can be hex string or ConsoleColor name
        [string]$BG, # Can be hex string or ConsoleColor name
        [switch]$Bold,
        [switch]$Italic,
        [switch]$Underline
    )
    
    # For PowerShell 7.2+ with PSStyle support
    if ($PSVersionTable.PSVersion.Major -ge 7 -and $PSVersionTable.PSVersion.Minor -ge 2) {
        $style = ""
        
        $fgHex = Get-ConsoleColorHex $FG
        $bgHex = Get-ConsoleColorHex $BG

        if ($fgHex -match '^#[0-9A-Fa-f]{6}$') {
            $style += "`e[38;2;$([Convert]::ToInt32($fgHex.Substring(1,2), 16));$([Convert]::ToInt32($fgHex.Substring(3,2), 16));$([Convert]::ToInt32($fgHex.Substring(5,2), 16))m"
        }
        
        if ($bgHex -match '^#[0-9A-Fa-f]{6}$') {
            $style += "`e[48;2;$([Convert]::ToInt32($bgHex.Substring(1,2), 16));$([Convert]::ToInt32($bgHex.Substring(3,2), 16));$([Convert]::ToInt32($bgHex.Substring(5,2), 16))m"
        }
        
        if ($Bold) { $style += "`e[1m" }
        if ($Italic) { $style += "`e[3m" }
        if ($Underline) { $style += "`e[4m" }
        
        return $style
    }
    
    return "" # No PSStyle support or invalid PSVersion
}

function Apply-PSStyle {
    param(
        [string]$Text,
        [string]$FG,
        [string]$BG,
        [switch]$Bold,
        [switch]$Italic,
        [switch]$Underline
    )
    
    $style = Get-PSStyleValue -FG $FG -BG $BG -Bold:$Bold -Italic:$Italic -Underline:$Underline
    
    if ($style) {
        return "${style}${Text}`e[0m"
    }
    
    # Fallback for older PowerShell versions or if PSStyle is disabled
    # Try to use Write-Host with legacy colors if no PSStyle
    # This function is for returning styled text, so Write-Host isn't a direct replacement.
    # For direct output, Write-Host with -ForegroundColor would be used.
    # Here, we just return the text if no styling can be applied.
    return $Text
}

#endregion

#region Theme-Based UI Functions

function Write-Header {
    param([string]$Text)
    
    $headerColor = Get-ThemeProperty "Palette.HeaderFG"
    $underlineColor = Get-ThemeProperty "Palette.SubtleFG" # Or a specific underline color
    if ($PSVersionTable.PSVersion.Major -ge 7 -and $PSVersionTable.PSVersion.Minor -ge 2) {
        Write-Host "`n$(Apply-PSStyle -Text $Text -FG $headerColor -Bold)"
        Write-Host "$(Apply-PSStyle -Text ('=' * $Text.Length) -FG $underlineColor)"
    } else {
        # Legacy fallback
        $legacyHeaderColor = $script:Data.Settings.Theme.Header # Assumes this path for legacy console color name
        $legacyUnderlineColor = "DarkCyan" # Fallback legacy color
        if ($script:Data.Settings.Theme.Subtle) { $legacyUnderlineColor = $script:Data.Settings.Theme.Subtle }

        Write-Host "`n$Text" -ForegroundColor $legacyHeaderColor
        Write-Host ("=" * $Text.Length) -ForegroundColor $legacyUnderlineColor
    }
}

function Write-Success {
    param([string]$Text)
    $color = Get-ThemeProperty "Palette.SuccessFG"
    $symbol = "✓"
    if ($PSVersionTable.PSVersion.Major -ge 7 -and $PSVersionTable.PSVersion.Minor -ge 2) {
        Write-Host "$(Apply-PSStyle -Text "$symbol $Text" -FG $color)"
    } else {
        $legacyColor = $script:Data.Settings.Theme.Success
        Write-Host "$symbol $Text" -ForegroundColor $legacyColor
    }
}

function Write-Warning {
    param([string]$Text)
    $color = Get-ThemeProperty "Palette.WarningFG"
    $symbol = "⚠"
    if ($PSVersionTable.PSVersion.Major -ge 7 -and $PSVersionTable.PSVersion.Minor -ge 2) {
        Write-Host "$(Apply-PSStyle -Text "$symbol $Text" -FG $color)"
    } else {
        $legacyColor = $script:Data.Settings.Theme.Warning
        Write-Host "$symbol $Text" -ForegroundColor $legacyColor
    }
}

function Write-Error {
    param([string]$Text)
    $color = Get-ThemeProperty "Palette.ErrorFG"
    $symbol = "✗"
    if ($PSVersionTable.PSVersion.Major -ge 7 -and $PSVersionTable.PSVersion.Minor -ge 2) {
        Write-Host "$(Apply-PSStyle -Text "$symbol $Text" -FG $color)"
    } else {
        $legacyColor = $script:Data.Settings.Theme.Error
        Write-Host "$symbol $Text" -ForegroundColor $legacyColor
    }
}

function Write-Info {
    param([string]$Text)
    $color = Get-ThemeProperty "Palette.InfoFG"
    $symbol = "ℹ"
    if ($PSVersionTable.PSVersion.Major -ge 7 -and $PSVersionTable.PSVersion.Minor -ge 2) {
        Write-Host "$(Apply-PSStyle -Text "$symbol $Text" -FG $color)"
    } else {
        $legacyColor = $script:Data.Settings.Theme.Info
        Write-Host "$symbol $Text" -ForegroundColor $legacyColor
    }
}

#endregion

#region Theme Configuration

function Edit-ThemeSettings {
    Write-Header "Theme Settings (Legacy Console Colors)"
    
    Write-Host "Current theme colors (Legacy Console Names):" -ForegroundColor Yellow
    $themeSettings = $script:Data.Settings.Theme
    Write-Host "  Header:  " -NoNewline; Write-Host "Sample" -ForegroundColor $themeSettings.Header
    Write-Host "  Success: " -NoNewline; Write-Host "Sample" -ForegroundColor $themeSettings.Success
    Write-Host "  Warning: " -NoNewline; Write-Host "Sample" -ForegroundColor $themeSettings.Warning
    Write-Host "  Error:   " -NoNewline; Write-Host "Sample" -ForegroundColor $themeSettings.Error
    Write-Host "  Info:    " -NoNewline; Write-Host "Sample" -ForegroundColor $themeSettings.Info
    Write-Host "  Accent:  " -NoNewline; Write-Host "Sample" -ForegroundColor $themeSettings.Accent
    Write-Host "  Subtle:  " -NoNewline; Write-Host "Sample" -ForegroundColor $themeSettings.Subtle
    
    Write-Host "`nAvailable PowerShell ConsoleColors:" -ForegroundColor Gray
    $availableColors = [System.Enum]::GetNames([System.ConsoleColor])
    Write-Host ($availableColors -join ", ")
    
    Write-Host "`nLeave empty to keep current color. These settings are for legacy compatibility." -ForegroundColor Gray
    Write-Host "Modern themes using hex codes would be managed differently (e.g., via JSON files)." -ForegroundColor DarkGray
    
    $colorsToEdit = @("Header", "Success", "Warning", "Error", "Info", "Accent", "Subtle")
    foreach ($colorType in $colorsToEdit) {
        $newColor = Read-Host "$colorType color ($($themeSettings[$colorType]))"
        if (-not [string]::IsNullOrWhiteSpace($newColor)) {
            if ($newColor -in $availableColors) {
                $script:Data.Settings.Theme[$colorType] = $newColor
            } else {
                Write-Warning "Invalid ConsoleColor '$newColor'. Keeping '$($themeSettings[$colorType])'."
            }
        }
    }
    
    Save-UnifiedData # Assumes Save-UnifiedData is in helper.ps1 or core-data.ps1
    Initialize-ThemeSystem # Re-initialize to apply changes
    Write-Success "Legacy theme console color settings updated!"
    Write-Info "Restart may be needed for full effect in some terminals if PSStyle is not active."
}

#endregion
# ui.ps1
# (Content from ui-ps1 (4).txt, with migrations from Pmc Mod Base.txt)

# UI Components Module
# Tables, menus, borders, and display functions

#region Table Formatting

function Format-TableUnicode {
    param(
        [Parameter(ValueFromPipeline)]
        [object[]]$Data,
        
        [hashtable[]]$Columns,
        
        [string]$BorderStyle = "Single", # Default can be set from theme $script:CurrentTheme.DataTable.BorderStyle
        [string]$Title = "",
        [switch]$NoHeader,
        [switch]$Wrap,
        [int]$MaxWidth = 0, # 0 means console width or auto
        [hashtable]$RowColors = @{}, # e.g. @{ Property = "Status"; Value = "Overdue"; Color = "Red" }
        [scriptblock]$RowColorCondition # e.g. { param($row) if ($row.Status -eq 'Overdue') { "Red" } }
    )
    
    begin {
        $allData = @()
        $effectiveBorderStyle = if ($script:CurrentTheme -and $script:CurrentTheme.DataTable) { $script:CurrentTheme.DataTable.BorderStyle } else { $BorderStyle }
        $border = Get-BorderStyleChars -Style $effectiveBorderStyle
        $dataTableHeaderFg = Get-ThemeProperty "DataTable.Header.FG"
        $dataTableRowFg = Get-ThemeProperty "DataTable.DataRow.FG"
        $dataTableRowAltFg = Get-ThemeProperty "DataTable.AltRow.FG"
        if (-not $dataTableHeaderFg) { $dataTableHeaderFg = Get-ThemeProperty "Palette.AccentFG" } # Fallback
        if (-not $dataTableRowFg) { $dataTableRowFg = Get-ThemeProperty "Palette.PrimaryFG" } # Fallback
        if (-not $dataTableRowAltFg) { $dataTableRowAltFg = Get-ThemeProperty "Palette.SecondaryFG" } # Fallback


        if ($MaxWidth -eq 0) {
            try {
                $MaxWidth = $Host.UI.RawUI.WindowSize.Width - 2 # Adjust for potential scrollbars/margins
            } catch {
                $MaxWidth = 80 # Fallback if console width cannot be determined
            }
        }
    }
    
    process {
        if ($Data) {
            $allData += $Data
        }
    }
    
    end {
        if ($allData.Count -eq 0) {
            Write-Host "No data to display" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG" )
            return
        }
        
        # Auto-generate columns if not provided
        if (-not $Columns) {
            $props = $allData[0].PSObject.Properties | Where-Object { $_.MemberType -eq 'NoteProperty' }
            $Columns = $props | ForEach-Object {
                @{
                    Name = $_.Name
                    Title = $_.Name # Capitalize first letter for default title
                    Width = 0      # Auto-size
                    Align = "Left" # Default alignment
                }
            }
        }
        
        # Calculate column widths
        foreach ($col in $Columns) {
            if ($col.Width -eq 0 -or -not $col.ContainsKey("Width")) {
                # Auto-size column
                $maxLen = $col.Title.ToString().Length
                foreach ($item in $allData) {
                    $value = Get-PropertyValue $item $col.Name
                    $len = if ($value) { $value.ToString().Length } else { 0 }
                    if ($len -gt $maxLen) { $maxLen = $len }
                }
                # Add padding, default to 2 if not specified by theme
                $colPad = if ($script:CurrentTheme -and $script:CurrentTheme.DataTable) { $script:CurrentTheme.DataTable.Pad * 2 } else { 2 } 
                $col.Width = [Math]::Min($maxLen + $colPad, 50)  # Cap at 50 chars default
            }
            if (-not $col.ContainsKey("Align")) {
                $col.Align = "Left" # Default alignment
            }
        }
        
        # Calculate total width required by columns
        $contentTotalWidth = ($Columns | Measure-Object -Property Width -Sum).Sum
        $totalTableWidth = $contentTotalWidth + ($Columns.Count + 1) # borders

        if ($MaxWidth -gt 0 -and $totalTableWidth -gt $MaxWidth) {
            # Proportional adjustment logic:
            # Calculate overflow and distribute reduction proportionally, ensuring min width (e.g., 5).
            $overflow = $totalTableWidth - $MaxWidth
            $adjustableWidth = $contentTotalWidth # Sum of all column widths we can adjust
            
            foreach ($col in $Columns) {
                if ($adjustableWidth -le 0) { break } # Avoid division by zero
                $proportionalReduction = [int](($col.Width / $adjustableWidth) * $overflow)
                $newWidth = $col.Width - $proportionalReduction
                $col.Width = [Math]::Max(5, $newWidth) # Ensure minimum width
            }
            # Recalculate total width after adjustments
            $contentTotalWidth = ($Columns | Measure-Object -Property Width -Sum).Sum
            $totalTableWidth = $contentTotalWidth + ($Columns.Count + 1)
        }
        
        # Draw top border
        Write-Host $border.TopLeft -NoNewline
        for ($i = 0; $i -lt $Columns.Count; $i++) {
            Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline
            if ($i -lt $Columns.Count - 1) {
                Write-Host $border.TTop -NoNewline
            }
        }
        Write-Host $border.TopRight
        
        # Draw title if provided
        if ($Title) {
            Write-Host $border.Vertical -NoNewline
            $titleContentWidth = $totalTableWidth - 2
            $titlePadded = " $Title ".PadRight($titleContentWidth).Substring(0, $titleContentWidth)
            Write-Host (Apply-PSStyle -Text $titlePadded -FG (Get-ThemeProperty "Palette.HeaderFG") -Bold) -NoNewline
            Write-Host $border.Vertical
            
            # Title separator
            Write-Host $border.TLeft -NoNewline
            for ($i = 0; $i -lt $Columns.Count; $i++) {
                Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline
                if ($i -lt $Columns.Count - 1) {
                    Write-Host $border.Cross -NoNewline
                }
            }
            Write-Host $border.TRight
        }
        
        # Draw header
        if (-not $NoHeader) {
            Write-Host $border.Vertical -NoNewline
            foreach ($col in $Columns) {
                $headerText = Format-TableCell -Text $col.Title -Width $col.Width -Align "Center" # Headers often centered
                Write-Host (Apply-PSStyle -Text $headerText -FG $dataTableHeaderFg -Bold) -NoNewline
                Write-Host $border.Vertical -NoNewline
            }
            Write-Host
            
            # Header separator (use Cross if title was present, otherwise TLeft/TRight)
            $headerSepLeft = if ($Title) { $border.TLeft } else { $border.TLeft }
            $headerSepRight = if ($Title) { $border.TRight } else { $border.TRight }
            $headerSepCross = $border.Cross
            
            Write-Host $headerSepLeft -NoNewline
            for ($i = 0; $i -lt $Columns.Count; $i++) {
                Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline
                if ($i -lt $Columns.Count - 1) {
                    Write-Host $headerSepCross -NoNewline
                }
            }
            Write-Host $headerSepRight
        }
        
        # Draw data rows
        $rowIndex = 0
        foreach ($item in $allData) {
            Write-Host $border.Vertical -NoNewline
            
            # Determine row color
            $effectiveRowColor = if ($rowIndex % 2 -eq 1 -and $dataTableRowAltFg) { $dataTableRowAltFg } else { $dataTableRowFg }
            $customColor = $null
            if ($RowColorCondition) {
                $customColor = & $RowColorCondition $item # Scriptblock should return a color string or $null
            } elseif ($RowColors.Count -gt 0) {
                foreach($rcKey in $RowColors.Keys) {
                    if ($item.$($RowColors[$rcKey].Property) -eq $RowColors[$rcKey].Value) {
                        $customColor = $RowColors[$rcKey].Color
                        break
                    }
                }
            }
            if ($customColor) { $effectiveRowColor = $customColor }


            foreach ($col in $Columns) {
                $value = Get-PropertyValue $item $col.Name
                $cellText = Format-TableCell -Text $value -Width $col.Width -Align $col.Align -Wrap:$Wrap
                
                Write-Host (Apply-PSStyle -Text $cellText -FG $effectiveRowColor) -NoNewline
                Write-Host $border.Vertical -NoNewline
            }
            Write-Host
            $rowIndex++
        }
        
        # Draw bottom border
        Write-Host $border.BottomLeft -NoNewline
        for ($i = 0; $i -lt $Columns.Count; $i++) {
            Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline
            if ($i -lt $Columns.Count - 1) {
                Write-Host $border.TBottom -NoNewline
            }
        }
        Write-Host $border.BottomRight
    }
}

function Format-TableCell {
    param(
        [string]$Text,
        [int]$Width,
        [string]$Align = "Left",
        [switch]$Wrap # Placeholder for future wrap implementation
    )
    
    $actualText = if ($null -eq $Text) { "" } else { $Text.ToString() }
    $pad = if ($script:CurrentTheme -and $script:CurrentTheme.DataTable) { $script:CurrentTheme.DataTable.Pad } else { 1 } 
    $contentWidth = $Width - ($pad * 2)

    if ($contentWidth -lt 1) { # Not enough space for content and padding
        return " " * $Width # Return empty cell of correct width
    }

    if ($actualText.Length -gt $contentWidth) {
        if ($Wrap) {
            # Basic wrapping (more advanced wrapping would be complex here)
            # This is a simplified version, real wrapping needs multi-line support in the table
            $actualText = $actualText.Substring(0, $contentWidth - 1) + "…" # Indicate truncation for now
        } else {
            $actualText = $actualText.Substring(0, $contentWidth - 1) + "…"
        }
    }
    
    $paddingLeft = " " * $pad
    $paddingRight = " " * $pad
    
    $paddedText = switch ($Align.ToLower()) {
        "center" { 
            $totalPadding = $contentWidth - $actualText.Length
            $leftPadCount = [Math]::Floor($totalPadding / 2)
            $rightPadCount = $totalPadding - $leftPadCount
            "$($paddingLeft)$(' ' * $leftPadCount)$actualText$(' ' * $rightPadCount)$($paddingRight)"
        }
        "right"  { "$($paddingLeft)$(' ' * ($contentWidth - $actualText.Length))$actualText$($paddingRight)" }
        default  { "$($paddingLeft)$actualText$(' ' * ($contentWidth - $actualText.Length))$($paddingRight)" } # Left
    }
    
    # Ensure the final string is exactly $Width characters long
    if ($paddedText.Length -gt $Width) {
        return $paddedText.Substring(0, $Width)
    } elseif ($paddedText.Length -lt $Width) {
        return $paddedText.PadRight($Width)
    }
    return $paddedText
}

function Get-PropertyValue {
    param($Object, $PropertyName)
    
    if ($null -eq $Object) { return "" }

    if ($PropertyName -contains ".") {
        $parts = $PropertyName -split '\.'
        $current = $Object
        foreach ($part in $parts) {
            if ($null -eq $current) { return "" }
            # Check if $current is a PSCustomObject or Hashtable and has the property/key
            if (($current -is [System.Management.Automation.PSCustomObject] -and $null -ne $current.PSObject.Properties[$part]) -or
                ($current -is [hashtable] -and $current.ContainsKey($part))) {
                $current = $current.$part
            } else {
                return "" # Property/key not found
            }
        }
        return if ($null -eq $current) { "" } else { $current.ToString() }
    }
    
    # Handle direct property access
    if (($Object -is [System.Management.Automation.PSCustomObject] -and $null -ne $Object.PSObject.Properties[$PropertyName]) -or
        ($Object -is [hashtable] -and $Object.ContainsKey($PropertyName))) {
        $value = $Object.$PropertyName
        return if ($null -eq $value) { "" } else { $value.ToString() }
    }
    
    return "" # PropertyName not found
}

#endregion

#region Dashboard Display (from ui-ps1 (4).txt)

function Show-Dashboard {
    Clear-Host
    
    # Header Section (Uses direct Write-Host with fixed characters as per original)
    Write-Host @"
╔═══════════════════════════════════════════════════════════╗
║          UNIFIED PRODUCTIVITY SUITE v5.0                  ║
║               All-in-One Command Center                   ║
╚═══════════════════════════════════════════════════════════╝
"@ -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")

    # Quick stats
    $activeTimers = if ($script:Data -and $script:Data.ActiveTimers) { $script:Data.ActiveTimers.Count } else { 0 }
    $activeTasks = if ($script:Data -and $script:Data.Tasks) { ($script:Data.Tasks | Where-Object { -not $_.Completed -and ($_.IsCommand -ne $true -or ($_.IsCommand -eq $true -and $script:Data.Settings.CommandSnippets.ShowInTaskList -eq $true) ) }).Count } else { 0 }
    $todayHours = 0
    if ($script:Data -and $script:Data.TimeEntries) {
        $todayHours = ($script:Data.TimeEntries | Where-Object { $_.Date -eq (Get-Date).ToString("yyyy-MM-dd") } | Measure-Object -Property Hours -Sum).Sum
        $todayHours = if ($todayHours) { [Math]::Round($todayHours, 2) } else { 0 }
    }
    
    Write-Host "`n📊 CURRENT STATUS" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host "═══════════════════════════════════════════" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    
    Write-Host "  📅 Today: " -NoNewline
    Write-Host (Get-Date).ToString("dddd, MMMM dd, yyyy") -ForegroundColor (Get-ThemeProperty "Palette.PrimaryFG")
    
    Write-Host "  ⏱️  Today's Hours: " -NoNewline
    if ($todayHours -gt 0) {
        Write-Host "$todayHours" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
    } else {
        Write-Host "None logged" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    }
    
    Write-Host "  ⏰ Active Timers: " -NoNewline
    if ($activeTimers -gt 0) {
        Write-Host "$activeTimers running" -ForegroundColor (Get-ThemeProperty "Palette.ErrorFG")
        
        if ($script:Data.ActiveTimers) {
            foreach ($timer in $script:Data.ActiveTimers.GetEnumerator() | Select-Object -First 2) {
                $elapsed = (Get-Date) - [DateTime]$timer.Value.StartTime
                $project = if (Get-Command Get-ProjectOrTemplate -ErrorAction SilentlyContinue) { Get-ProjectOrTemplate $timer.Value.ProjectKey } else { @{Name="Project?"} }
                Write-Host "     → $($project.Name): $([Math]::Floor($elapsed.TotalHours)):$($elapsed.ToString('mm\:ss'))" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")
            }
            if ($script:Data.ActiveTimers.Count -gt 2) {
                Write-Host "     → ... and $($script:Data.ActiveTimers.Count - 2) more" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
            }
        }
    } else {
        Write-Host "None" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
    }
    
    Write-Host "  ✅ Active Tasks: " -NoNewline # Excluding commands from this count
    $actualActiveTasks = if ($script:Data -and $script:Data.Tasks) { ($script:Data.Tasks | Where-Object { -not $_.Completed -and $_.IsCommand -ne $true }).Count } else { 0 }
    if ($actualActiveTasks -gt 0) {
        Write-Host "$actualActiveTasks" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
        
        if ($script:Data.Tasks) {
            $overdue = $script:Data.Tasks | Where-Object {
                $_.IsCommand -ne $true -and $_.DueDate -and ([datetime]::Parse($_.DueDate) -lt [datetime]::Today) -and -not $_.Completed
            }
            $dueToday = $script:Data.Tasks | Where-Object {
                $_.IsCommand -ne $true -and $_.DueDate -and ([datetime]::Parse($_.DueDate).Date -eq [datetime]::Today.Date) -and -not $_.Completed
            }
            
            if ($overdue.Count -gt 0) {
                Write-Host "     ⚠️  $($overdue.Count) overdue!" -ForegroundColor (Get-ThemeProperty "Palette.ErrorFG")
            }
            if ($dueToday.Count -gt 0) {
                Write-Host "     📅 $($dueToday.Count) due today" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
            }
        }
    } else {
        Write-Host "None - inbox zero! 🎉" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
    }
    
    Write-Host "  📁 Active Projects: " -NoNewline
    $activeProjectsCount = if ($script:Data -and $script:Data.Projects) { ($script:Data.Projects.Values | Where-Object { $_.Status -eq "Active" }).Count } else { 0 }
    Write-Host $activeProjectsCount -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
    
    # Check for command snippets
    $commandCount = if ($script:Data -and $script:Data.Tasks) { ($script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }).Count } else { 0 }
    if ($commandCount -gt 0) {
        Write-Host "  💡 Command Snippets: " -NoNewline
        Write-Host $commandCount -ForegroundColor (Get-ThemeProperty "Palette.InfoFG") # Or a distinct color for snippets
    }
    
    # Week summary
    Write-Host "`n📈 WEEK SUMMARY" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host "═══════════════════════════════════════════" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    
    $weekStart = if (Get-Command Get-WeekStart -ErrorAction SilentlyContinue) { Get-WeekStart } else { (Get-Date).Date }
    $weekHours = 0
    $targetHours = 0
    if ($script:Data -and $script:Data.TimeEntries -and $script:Data.Settings) {
        $weekEntries = $script:Data.TimeEntries | Where-Object {
            $entryDate = [DateTime]::Parse($_.Date)
            $entryDate -ge $weekStart -and $entryDate -lt $weekStart.AddDays(7)
        }
        $weekHours = ($weekEntries | Measure-Object -Property Hours -Sum).Sum
        $weekHours = if ($weekHours) { [Math]::Round($weekHours, 2) } else { 0 }
        $targetHours = $script:Data.Settings.HoursPerDay * $script:Data.Settings.DaysPerWeek
    }
    
    Write-Host "  Week of: $($weekStart.ToString('MMM dd, yyyy'))"
    Write-Host "  Total Hours: $weekHours / $targetHours target"
    
    # Progress bar for week
    $weekProgress = if ($targetHours -gt 0) { [Math]::Min(100, [Math]::Round(($weekHours / $targetHours) * 100, 0)) } else { 0 }
    
    $progressColor = Get-ThemeProperty "Palette.ErrorFG" # Default to Red
    if ($weekProgress -ge 80) { $progressColor = Get-ThemeProperty "Palette.SuccessFG" }
    elseif ($weekProgress -ge 50) { $progressColor = Get-ThemeProperty "Palette.WarningFG" }
    
    $barWidth = 20 # Width of the progress bar in characters
    $filledCount = [Math]::Floor($barWidth * ($weekProgress / 100))
    $emptyCount = $barWidth - $filledCount
    $progressBar = "[" + ("█" * $filledCount) + ("░" * $emptyCount) + "]"
    
    Write-Host "  Progress: $(Apply-PSStyle -Text "$progressBar $weekProgress%" -FG $progressColor)"
    
    # Quick actions (as defined in main.ps1's help, slightly adapted)
    Write-Host "`n⚡ QUICK ACTIONS" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host "═══════════════════════════════════════════" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    Write-Host "  [M] Manual Time (+m)   [S] Start Timer (+s)   [A] Add Task (+a)"
    Write-Host "  [V] View Timers (+v)   [T] Today's Tasks (+t) [W] Week Report (+w)"
    Write-Host "  [P] Projects (+p)      [C] Cmd Snippets (+c)  [H] Help (+h)"
    
    Write-Host "`n🔧 FULL MENU OPTIONS" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host "═══════════════════════════════════════════" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    Write-Host "  [1] Time Management     [4] Projects & Clients"
    Write-Host "  [2] Task Management     [5] Tools & Utilities"
    Write-Host "  [3] Reports & Analytics [6] Settings & Config"
    Write-Host "`n  [Q] Quit"
}

#endregion

#region Calendar Display (from ui-ps1 (4).txt)

function Show-Calendar {
    param(
        [DateTime]$Month = (Get-Date),
        [DateTime[]]$HighlightDates = @() # Not used in current impl but good param
    )
    
    Write-Header "Calendar - $($Month.ToString('MMMM yyyy'))"
    
    $firstDayOfMonth = Get-Date $Month -Day 1
    $lastDayOfMonth = $firstDayOfMonth.AddMonths(1).AddDays(-1)
    # PowerShell DayOfWeek: Sunday = 0, Monday = 1, ..., Saturday = 6
    $startOffset = [int]$firstDayOfMonth.DayOfWeek 
    
    # Header
    Write-Host "  Sun  Mon  Tue  Wed  Thu  Fri  Sat" -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
    Write-Host "  " + ("─" * 35) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    
    # Calculate task counts per day for the current month
    $tasksByDate = @{}
    if ($script:Data -and $script:Data.Tasks) {
        $script:Data.Tasks | Where-Object { $_.DueDate -and $_.IsCommand -ne $true } | ForEach-Object {
            try {
                $date = [DateTime]::Parse($_.DueDate).Date
                if ($date.Month -eq $Month.Month -and $date.Year -eq $Month.Year) {
                    if (-not $tasksByDate.ContainsKey($date)) {
                        $tasksByDate[$date] = 0
                    }
                    $tasksByDate[$date]++
                }
            } catch {
                # Ignore tasks with unparseable due dates for calendar view
            }
        }
    }
    
    # Days
    Write-Host -NoNewline "  " # Initial indent for the first row
    
    # Empty cells before the first day of the month
    for ($i = 0; $i -lt $startOffset; $i++) {
        Write-Host -NoNewline "     " # 5 spaces for " DD* "
    }
    
    # Days of the month
    for ($day = 1; $day -le $lastDayOfMonth.Day; $day++) {
        $currentDate = Get-Date -Year $Month.Year -Month $Month.Month -Day $day
        $dayOfWeek = [int]$currentDate.DayOfWeek
        
        $dayStr = $day.ToString().PadLeft(2) # Format day as "DD"
        
        # Determine color
        $dayDisplayColor = Get-ThemeProperty "Palette.PrimaryFG" # Default
        if ($currentDate.Date -eq [DateTime]::Today.Date) {
            $dayDisplayColor = Get-ThemeProperty "Palette.SuccessFG" # Today
        } elseif ($tasksByDate.ContainsKey($currentDate.Date)) {
            $count = $tasksByDate[$currentDate.Date]
            if ($count -ge 3) {
                $dayDisplayColor = Get-ThemeProperty "Palette.ErrorFG" # Busy (many tasks)
            } elseif ($count -ge 1) {
                $dayDisplayColor = Get-ThemeProperty "Palette.WarningFG" # Has tasks
            }
        } elseif ($dayOfWeek -eq 0 -or $dayOfWeek -eq 6) { # Sunday or Saturday
            $dayDisplayColor = Get-ThemeProperty "Palette.SubtleFG" # Weekend
        }
        
        Write-Host -NoNewline " " # Space before day
        Write-Host -NoNewline $dayStr -ForegroundColor $dayDisplayColor
        
        # Task indicator
        if ($tasksByDate.ContainsKey($currentDate.Date)) {
            Write-Host -NoNewline "*" -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
        } else {
            Write-Host -NoNewline " " # Placeholder for task indicator
        }
        Write-Host -NoNewline " " # Space after day/indicator
        
        # Newline after Saturday or if it's the last day and not Saturday
        if ($dayOfWeek -eq 6) {
            Write-Host
            if ($day -lt $lastDayOfMonth.Day) {
                Write-Host -NoNewline "  " # Indent for next row
            }
        }
    }
    Write-Host # Ensure a final newline if the month doesn't end on Saturday
    Write-Host "`n"
    
    # Legend
    Write-Host "  Legend: " -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    Write-Host "Today" -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")
    Write-Host " | Tasks*" -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
    Write-Host " | Has Tasks" -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host " | Busy" -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.ErrorFG")
    Write-Host "`n"
    
    # Navigation
    Write-Host "  [P]revious Month | [N]ext Month | [T]oday's Month | [Y]ear View | [B]ack"
    $nav = Read-Host "  Calendar Navigation"
    
    switch ($nav.ToUpper()) {
        "P" { Show-Calendar -Month $Month.AddMonths(-1) }
        "N" { Show-Calendar -Month $Month.AddMonths(1) }
        "T" { Show-Calendar -Month (Get-Date) }
        "Y" { Show-YearCalendar -Year $Month.Year }
        "B" { return } # Back to previous menu
        default { Show-Calendar -Month $Month } # Redisplay current on invalid input
    }
}

function Show-YearCalendar {
    param([int]$Year = (Get-Date).Year)
    
    Write-Header "Calendar - $Year"
    
    # Display 3 months per row
    for ($row = 0; $row -lt 4; $row++) { # 4 rows of 3 months
        $monthsInRow = @()
        for ($col = 0; $col -lt 3; $col++) {
            $monthNum = $row * 3 + $col + 1
            if ($monthNum -le 12) {
                $monthsInRow += Get-Date -Year $Year -Month $monthNum -Day 1
            }
        }
        
        if ($monthsInRow.Count -eq 0) { break }

        # Month headers
        Write-Host # Blank line before month names
        foreach ($monthDate in $monthsInRow) {
            # Each month display area is roughly 22 chars: "  MonthName (padded to 20)  "
            Write-Host ("  " + $monthDate.ToString("MMMM").PadRight(20)) -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
            Write-Host "  " -NoNewline # Spacer between month blocks
        }
        Write-Host # Newline after month names
        
        # Day headers (Su Mo Tu We Th Fr Sa)
        foreach ($monthDate in $monthsInRow) {
            Write-Host "  Su Mo Tu We Th Fr Sa  " -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.InfoFG") # DarkCyan in original
        }
        Write-Host # Newline after day headers
        
        # Calculate max weeks needed for any month (usually 6)
        $maxWeeksInThisRow = 0
        foreach($monthDate in $monthsInRow) {
            $firstDay = Get-Date $monthDate -Day 1
            $startOffset = [int]$firstDay.DayOfWeek
            $daysInMonth = [DateTime]::DaysInMonth($Year, $monthDate.Month)
            $weeksNeeded = [Math]::Ceiling(($daysInMonth + $startOffset) / 7)
            if ($weeksNeeded -gt $maxWeeksInThisRow) { $maxWeeksInThisRow = $weeksNeeded }
        }
        
        # Display days for each month in the row, week by week
        for ($weekIndex = 0; $weekIndex -lt $maxWeeksInThisRow; $weekIndex++) {
            foreach ($monthDate in $monthsInRow) {
                Write-Host "  " -NoNewline # Indent for this month's week line
                
                $firstDayOfMonth = Get-Date $monthDate -Day 1
                $lastDayOfMonth = $firstDayOfMonth.AddMonths(1).AddDays(-1)
                $startOffsetInMonth = [int]$firstDayOfMonth.DayOfWeek
                
                for ($dayOfWeekIndex = 0; $dayOfWeekIndex -lt 7; $dayOfWeekIndex++) { # Sun to Sat
                    # Calculate actual day number for current cell
                    $dayNumber = ($weekIndex * 7) + $dayOfWeekIndex - $startOffsetInMonth + 1
                    
                    if ($dayNumber -ge 1 -and $dayNumber -le $lastDayOfMonth.Day) {
                        $currentCellDate = Get-Date -Year $Year -Month $monthDate.Month -Day $dayNumber
                        
                        $dayDisplay = $dayNumber.ToString().PadLeft(2)
                        $dayColor = Get-ThemeProperty "Palette.PrimaryFG" # Default
                        if ($currentCellDate.Date -eq [DateTime]::Today.Date) {
                            $dayColor = Get-ThemeProperty "Palette.SuccessFG" # Today
                        } elseif ($dayOfWeekIndex -eq 0 -or $dayOfWeekIndex -eq 6) { # Weekend
                            $dayColor = Get-ThemeProperty "Palette.SubtleFG"
                        }
                        Write-Host $dayDisplay -NoNewline -ForegroundColor $dayColor
                    } else {
                        Write-Host "  " -NoNewline # Empty cell (outside month days)
                    }
                    
                    if ($dayOfWeekIndex -lt 6) { # If not Saturday
                        Write-Host " " -NoNewline # Space between days
                    }
                }
                Write-Host "  " -NoNewline # Spacer after this month's week line, before next month's
            }
            Write-Host # Newline after processing all months for this week
        }
         Write-Host # Extra blank line between rows of months for readability
    }
    
    Write-Host "`n  [P]revious Year | [N]ext Year | [T]oday's Year | [B]ack to Month View"
    $nav = Read-Host "  Year Calendar Navigation"
    
    switch ($nav.ToUpper()) {
        "P" { Show-YearCalendar -Year ($Year - 1) }
        "N" { Show-YearCalendar -Year ($Year + 1) }
        "T" { Show-YearCalendar -Year (Get-Date).Year }
        "B" { Show-Calendar -Month (Get-Date -Year $Year -Month (Get-Date).Month -Day 1); return } # Back to current month of displayed year
        default { Show-YearCalendar -Year $Year } # Redisplay current on invalid input
    }
}

#endregion

#region Progress Bar (from ui-ps1 (4).txt)

function Draw-ProgressBar {
    param(
        [int]$Percent,
        [int]$Width = 20,
        [string]$FillChar = "█",
        [string]$EmptyChar = "░",
        [string]$ForegroundColor = "Green", # ConsoleColor name or Hex
        [string]$BackgroundColor = "DarkGray" # ConsoleColor name or Hex
    )
    
    $clampedPercent = [Math]::Max(0, [Math]::Min(100, $Percent))
    $filled = [Math]::Floor($Width * ($clampedPercent / 100))
    $empty = $Width - $filled
    
    Write-Host "[" -NoNewline
    Write-Host (Apply-PSStyle -Text ($FillChar * $filled) -FG $ForegroundColor) -NoNewline
    Write-Host (Apply-PSStyle -Text ($EmptyChar * $empty) -FG $BackgroundColor) -NoNewline
    Write-Host "] $($clampedPercent)%" -NoNewline
}

#endregion

#region Menu Display (from ui-ps1 (4).txt, serves as Show-Menu from report)

function Show-MenuSelection {
    param(
        [string]$Title,
        [object[]]$Options, # Can be string array or array of hashtables @{Label=".."; Value=".."} or @{Name=".."; Action={...}}
        [string]$Prompt = "Select option",
        [switch]$AllowMultiple,
        [switch]$ReturnIndex, # If $true, returns index, else returns selected option object/string
        [string]$CancelOptionLabel = "Cancel", # Label for cancel option
        [string]$CancelOptionKey = "0" # Key for cancel option
    )
    
    Write-Header $Title
    
    $optionObjects = @() # To store the actual objects if $Options contains complex items

    for ($i = 0; $i -lt $Options.Count; $i++) {
        $option = $Options[$i]
        $label = ""
        if ($option -is [hashtable]) {
            if ($option.ContainsKey("Label")) { $label = $option.Label }
            elseif ($option.ContainsKey("Name")) { $label = $option.Name }
            else { $label = $option.ToString() } # Fallback
            $optionObjects += $option
        } elseif ($option -is [string]) {
            $label = $option
            $optionObjects += $option
        } else { # PSCustomObject or other
            $label = $option.ToString() # Basic fallback
            if ($option.PSObject.Properties["Label"]) { $label = $option.Label }
            elseif ($option.PSObject.Properties["Name"]) { $label = $option.Name }
            $optionObjects += $option
        }
        Write-Host "[$($i + 1)] $label"
    }
    
    if ($AllowMultiple) {
        Write-Host "`nEnter numbers separated by commas (e.g., 1,3,5)"
        Write-Host "Or enter 'all' to select all, 'none' to cancel"
    } else {
        Write-Host "`n[$CancelOptionKey] $CancelOptionLabel"
    }
    
    $selectionInput = Read-Host "`n$Prompt"
    
    if ($AllowMultiple) {
        if ($selectionInput -eq 'all') {
            if ($ReturnIndex) {
                return 0..($optionObjects.Count - 1)
            } else {
                return $optionObjects
            }
        } elseif ($selectionInput -eq 'none' -or [string]::IsNullOrWhiteSpace($selectionInput)) {
            return @() # Empty array for no selection
        }
        
        $selectedItems = @()
        $indices = $selectionInput -split ',' | ForEach-Object { $_.Trim() }
        foreach ($numStr in $indices) {
            if ($numStr -match '^\d+$') {
                $idx = [int]$numStr - 1
                if ($idx -ge 0 -and $idx -lt $optionObjects.Count) {
                    if ($ReturnIndex) { $selectedItems += $idx } else { $selectedItems += $optionObjects[$idx] }
                } else { Write-Warning "Invalid option number: $numStr" }
            } else { Write-Warning "Invalid input: $numStr" }
        }
        return $selectedItems | Select-Object -Unique # Ensure unique if numbers repeated
    } else { # Single selection
        if ($selectionInput -eq $CancelOptionKey -or [string]::IsNullOrWhiteSpace($selectionInput)) {
            return $null # Standard cancellation return
        }
        
        if ($selectionInput -match '^\d+$') {
            $idx = [int]$selectionInput - 1
            if ($idx -ge 0 -and $idx -lt $optionObjects.Count) {
                if ($ReturnIndex) { return $idx } else { return $optionObjects[$idx] }
            }
        }
        
        Write-Error "Invalid selection."
        return $null # Invalid selection
    }
}

#endregion

#region Help Display (from ui-ps1 (4).txt)

function Show-Help {
    Clear-Host
    Write-Header "Help & Documentation - Unified Productivity Suite v5.0"
    
    # The help text from ui-ps1 (4).txt is quite comprehensive and includes quick actions
    Write-Host @"
UNIFIED PRODUCTIVITY SUITE v5.0
===============================

This integrated suite combines time tracking, task management, project
management, Excel integration, and command snippets into a seamless 
productivity system.

QUICK ACTIONS (use +key from any prompt):
----------------------------------------
+9, +m, +time     Manual time entry
+s, +timer        Start timer
+stop             Stop timer
+a, +task         Add task
+qa               Quick add task (e.g., +qa My new task #category !high due:tomorrow)
+t                Today's tasks / Today View
+v                View active timers
+w, +week         Week report
+p                Project details / Project Menu
+c, +cmd          Command snippets
+h, +help         This main help screen
+?                Quick action help (list of +key commands)
+cal              Show Calendar
+export           Export formatted timesheet

TIME TRACKING:
-------------
- Manual entry (+m) is flexible for logging time after work is done.
- Live timers (+s) for real-time tracking.
- Link time entries to tasks for granular reporting.
- Budget warnings for projects.
- Quick time entry format from main menu: PROJECT_KEY HOURS [DESCRIPTION]

TASK MANAGEMENT:
---------------
- Smart sorting in task views prioritizes by urgency and importance.
- Multiple views available via Task Management menu.
- Subtasks support for complex work.
- Progress tracking, can be auto-calculated from subtasks.
- Quick add task syntax (+qa): DESCRIPTION #category @tags !priority due:date project:KEY est:HOURS

PROJECT MANAGEMENT:
------------------
- Add projects manually or import from Excel (configurable mapping).
- Track budgets, billing rates, status.
- View project statistics (time, tasks).

COMMAND SNIPPETS (+c):
--------------------
- Store and retrieve frequently used commands or code.
- Organize by category and tags.
- Optional hotkeys (requires external setup if OS-wide).
- Auto-copy to clipboard option.

EXCEL INTEGRATION:
-----------------
- Configure mappings for importing project data from Excel forms.
- Reusable Excel copy configurations for transferring data between sheets/workbooks.

FORMATTED TIMESHEET (+export):
---------------------------
- Creates a CSV file suitable for import into external systems.
- Columns: ID1, ID2, (empty), (empty), (empty), (empty), Mon_Hours, Tue_Hours, ...

KEYBOARD SHORTCUTS (within specific views, e.g., Task List):
------------------
- Contextual shortcuts are often listed at the bottom of the view.
  Examples: 'c <id>' (complete), 'e <id>' (edit), 'd <id>' (delete)

DATA STORAGE:
------------
All data is stored in JSON format in: $script:DataPath (typically ~/.ProductivitySuite)
Automatic backups are created in the 'backups' subfolder.

TIPS:
----
1. Explore +key quick actions for fast navigation and operations.
2. Customize project templates and Excel form mappings in Settings.
3. Regularly archive completed tasks to keep views clean.
4. Use the Dashboard for a daily overview and quick access.
5. Leverage command snippets for repetitive shell commands or code blocks.
"@ -ForegroundColor (Get-ThemeProperty "Palette.PrimaryFG")
    
    Write-Host "`nPress any key to return..." -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

#endregion

#region Migrated Task UI functions from Pmc Mod Base.txt

function Show-TasksView {
    param(
        [string]$Filter = "",
        [string]$SortBy = "Smart", # Default sort
        [switch]$ShowCompleted,
        [string]$View = "Default" # Default view type
    )
   
    # Get tasks, excluding command snippets unless settings allow
    $tasksToDisplay = $script:Data.Tasks | Where-Object { 
        $_.IsCommand -ne $true -or ($_.IsCommand -eq $true -and $script:Data.Settings.CommandSnippets.ShowInTaskList -eq $true)
    }

    # Apply text filter
    if ($Filter) {
        $tasksToDisplay = $tasksToDisplay | Where-Object {
            $_.Description -like "*$Filter*" -or
            $_.Category -like "*$Filter*" -or
            ($_.Tags -join " ") -like "*$Filter*" -or # Search within joined tags
            $_.ProjectKey -like "*$Filter*" -or
            $_.Id -like "*$Filter*" # Allow filtering by ID
        }
    }
   
    # Filter completed based on ShowCompleted and settings
    if (-not $ShowCompleted) {
        $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.ShowCompletedDays)
        $tasksToDisplay = $tasksToDisplay | Where-Object {
            -not $_.Completed -or ($_.CompletedDate -and [datetime]::Parse($_.CompletedDate) -ge $cutoffDate)
        }
    }
   
    # Sorting logic
    $sortedTasks = switch ($SortBy.ToLower()) {
        "smart" {
            $tasksToDisplay | Sort-Object @{Expression={
                $statusValue = 8 # Default for unknown or general
                if ($_.Completed) { $statusValue = 10 } # Completed last in smart sort
                else {
                    switch(Get-TaskStatus $_) { # Assumes Get-TaskStatus is in core-data.ps1
                        "Overdue"     { $statusValue = 1 }
                        "Due Today"   { $statusValue = 2 }
                        "Critical"    { $statusValue = 3 } # If priority is main factor
                        "High"        { $statusValue = 4 }
                        "Due Soon"    { $statusValue = 5 }
                        "In Progress" { $statusValue = 6 }
                        "Medium"      { $statusValue = 7 }
                        "Scheduled"   { $statusValue = 8 }
                        "Low"         { $statusValue = 9 }
                        "Pending"     { $statusValue = 9 } # Pending/Low together
                    }
                }
                $statusValue
            }}, @{Expression={ # Secondary sort by priority numerical value
                switch($_.Priority.ToLower()) {
                    "critical" { 1 }
                    "high"     { 2 }
                    "medium"   { 3 }
                    "low"      { 4 }
                    default    { 5 }
                }
            }}, DueDate, CreatedDate
        }
        "priority" {
            $tasksToDisplay | Sort-Object @{Expression={
                switch($_.Priority.ToLower()) {
                    "critical" { 1 } "high" { 2 } "medium" { 3 } "low" { 4 } default { 5 }
                }
            }}, DueDate, CreatedDate
        }
        "duedate"  { $tasksToDisplay | Sort-Object @{Expression={if ($_.DueDate) {[datetime]$_.DueDate} else {[datetime]::MaxValue}}}, Priority }
        "created"  { $tasksToDisplay | Sort-Object CreatedDate -Descending } # Most recent first
        "category" { $tasksToDisplay | Sort-Object Category, Priority }
        "project"  { $tasksToDisplay | Sort-Object ProjectKey, Priority }
        default    { $tasksToDisplay } # No sort or fallback
    }
   
    if ($sortedTasks.Count -eq 0) {
        Write-Host "`n  📭 No tasks match your criteria." -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")
        Show-TaskStatistics $sortedTasks # Show stats even for empty set (will show 0s)
        return
    }
   
    # Display using the chosen view mode
    switch ($View.ToLower()) {
        "kanban"   { Show-KanbanView $sortedTasks }
        "timeline" { Show-TimelineView $sortedTasks }
        "project"  { Show-ProjectTaskView $sortedTasks }
        default    { Show-TaskListView $sortedTasks } # "List" or "Default" view
    }
   
    Show-TaskStatistics $sortedTasks # Display statistics at the bottom
}

function Show-TaskListView {
    param($Tasks)
   
    # Define columns for Format-TableUnicode
    $columns = @(
        @{Name="Icon"; Title="S"; Width=3} # Status/Priority Icon
        @{Name="Id"; Title="ID"; Width=7}
        @{Name="Description"; Title="Description"; Width=40; Wrap=$true} # Allow wrapping for long descriptions
        @{Name="DueDate"; Title="Due"; Width=12}
        @{Name="Priority"; Title="Pri"; Width=6}
        @{Name="Progress"; Title="Prog"; Width=5; Align="Right"}
        @{Name="Project"; Title="Project"; Width=15}
        @{Name="Tags"; Title="Tags"; Width=20}
    )

    $tableData = $Tasks | ForEach-Object {
        $priorityInfo = Get-PriorityInfo $_.Priority # Assumes Get-PriorityInfo is in core-data.ps1
        $project = if ($_.ProjectKey) { (Get-ProjectOrTemplate $_.ProjectKey).Name } else { "-" } # Assumes Get-ProjectOrTemplate
        $progressDisplay = if ($_.Completed) { "Done" } elseif ($_.Progress -gt 0) { "$($_.Progress)%" } else { "-" }
        
        $statusIcon = if ($_.Completed) { Apply-PSStyle -Text "✅" -FG (Get-ThemeProperty "DataTable.Highlight.Completed.FG") } 
                      else { $priorityInfo.Icon }
        
        [PSCustomObject]@{
            Icon        = $statusIcon
            Id          = $_.Id.Substring(0,6)
            Description = $_.Description
            DueDate     = if ($_.DueDate) { Format-TodoDate $_.DueDate } else { "-" } # Assumes Format-TodoDate
            Priority    = $_.Priority.Substring(0, [Math]::Min($_.Priority.Length, 3))
            Progress    = $progressDisplay
            Project     = if ($project.Length -gt 13) { $project.Substring(0,12) + "…" } else { $project }
            Tags        = ($_.Tags -join ", ").ToString()
        }
    }
    
    # Define row color condition for overdue/due soon tasks
    $rowColorCondition = {
        param($rowItem) # $rowItem here is one of the PSCustomObjects from $tableData
        # To use this effectively, the original task object needs to be accessible
        # or critical status fields need to be part of $rowItem.
        # This is a simplified example if 'Status' was a direct property of $rowItem:
        # if ($rowItem.Status -eq "Overdue") { return Get-ThemeProperty "DataTable.Highlight.Overdue.FG" }
        # if ($rowItem.Status -eq "Due Today") { return Get-ThemeProperty "DataTable.Highlight.DueSoon.FG" }
        # For a more robust solution, Format-TableUnicode might need to accept original items too for conditional logic
        return $null 
    }

    Format-TableUnicode -Data $tableData -Columns $columns -Title "Task List" -NoHeader:$false -RowColorCondition $rowColorCondition
}

function Show-TaskItem {
    # This function was for a more verbose line-by-line display.
    # Show-TaskListView now uses Format-TableUnicode for a tabular display.
    # This function can be kept for detailed views or removed if Show-TaskListView is sufficient.
    # For now, let's comment it out as Show-TaskListView provides the primary list.
    # If needed for a "detail" view of a single task, it can be repurposed.
    <#
    param($Task)
   
    $icon = if ($Task.Completed) { "✅" } else { "⬜" }
    $priorityInfo = Get-PriorityInfo $Task.Priority # From core-data.ps1
    $id = $Task.Id.Substring(0, 6)
    $status = Get-TaskStatus $Task # From core-data.ps1
   
    # Main line
    Write-Host "  $icon [$id] " -NoNewline
    Write-Host $priorityInfo.Icon -NoNewline; Write-Host " " -NoNewline
   
    if ($Task.Completed) {
        Write-Host (Apply-PSStyle -Text $Task.Description -FG (Get-ThemeProperty "DataTable.Highlight.Completed.FG"))
    } else {
        $statusColor = Get-ThemeProperty "Palette.PrimaryFG" # Default
        switch ($status) {
            "Overdue"     { $statusColor = Get-ThemeProperty "Palette.ErrorFG" }
            "Due Today"   { $statusColor = Get-ThemeProperty "Palette.WarningFG" }
            "Due Soon"    { $statusColor = Get-ThemeProperty "Palette.InfoFG" }
            "In Progress" { $statusColor = Get-ThemeProperty "Palette.AccentFG" }
        }
        Write-Host (Apply-PSStyle -Text $Task.Description -FG $statusColor)
    }
   
    # Details line
    Write-Host "      " -NoNewline
    # ... (rest of the detailed output logic from Pmc Mod Base.txt if desired for a non-table view) ...
    Write-Host # Ensure newline
    #>
}

function Show-KanbanView {
    param($Tasks) # $Tasks are the filtered & sorted task objects
    Write-Header "Kanban Board"

    $todoTasks = $Tasks | Where-Object { -not $_.Completed -and ($_.Progress -eq 0 -or -not $_.Progress) }
    $inProgressTasks = $Tasks | Where-Object { -not $_.Completed -and $_.Progress -gt 0 -and $_.Progress -lt 100 }
    $doneTasks = $Tasks | Where-Object { $_.Completed -or $_.Progress -eq 100 }

    $columnsConfig = @(
        @{ Title="To Do"; Items = $todoTasks; Color = (Get-ThemeProperty "Palette.ErrorFG")}
        @{ Title="In Progress"; Items = $inProgressTasks; Color = (Get-ThemeProperty "Palette.WarningFG")}
        @{ Title="Done"; Items = $doneTasks; Color = (Get-ThemeProperty "Palette.SuccessFG")}
    )

    # Determine max items in any column for balanced display height
    $maxItems = 0
    foreach ($colDef in $columnsConfig) {
        if ($colDef.Items.Count -gt $maxItems) { $maxItems = $colDef.Items.Count }
    }
    if ($maxItems -eq 0) { Write-Host "No tasks to display in Kanban." -ForegroundColor Gray; return }
    $maxItems = [Math]::Min($maxItems, 10) # Limit rows to keep it manageable

    $colWidth = 25 # Approximate width for each Kanban column content

    # Draw Header
    $headerLine = ""
    $separatorLine = $Global:borderStyles.Single.TLeft
    foreach ($colDef in $columnsConfig) {
        $headerText = (" " + $colDef.Title + " ($($colDef.Items.Count))").PadRight($colWidth)
        $headerLine += Apply-PSStyle -Text $headerText -FG $colDef.Color -Bold
        $headerLine += $Global:borderStyles.Single.Vertical
        $separatorLine += ($Global:borderStyles.Single.Horizontal * $colWidth) + $Global:borderStyles.Single.Cross
    }
    $headerLine = $Global:borderStyles.Single.Vertical + $headerLine.Substring(0, $headerLine.Length-1) + $Global:borderStyles.Single.Vertical
    $separatorLine = $separatorLine.Substring(0, $separatorLine.Length-1) + $Global:borderStyles.Single.TRight
    
    Write-Host $Global:borderStyles.Single.TopLeft + ($Global:borderStyles.Single.Horizontal * (($colWidth + 1) * $columnsConfig.Count -1)) + $Global:borderStyles.Single.TopRight
    Write-Host $headerLine
    Write-Host $separatorLine

    # Draw Items
    for ($i = 0; $i -lt $maxItems; $i++) {
        $rowLine = $Global:borderStyles.Single.Vertical
        foreach ($colDef in $columnsConfig) {
            $cellText = " ".PadRight($colWidth) # Empty cell
            if ($i -lt $colDef.Items.Count) {
                $task = $colDef.Items[$i]
                $taskDesc = "$($task.Id.Substring(0,4)) $($task.Description)"
                if ($taskDesc.Length -gt ($colWidth-1)) { $taskDesc = $taskDesc.Substring(0, $colWidth-2) + "…" }
                $cellText = (" " + $taskDesc).PadRight($colWidth)
            }
            $rowLine += $cellText + $Global:borderStyles.Single.Vertical
        }
        Write-Host $rowLine
    }
    
    # Draw Footer
    $footerLine = $Global:borderStyles.Single.BottomLeft
    foreach ($colDef in $columnsConfig) {
         $footerLine += ($Global:borderStyles.Single.Horizontal * $colWidth) + $Global:borderStyles.Single.TBottom
    }
    $footerLine = $footerLine.Substring(0, $footerLine.Length-1) + $Global:borderStyles.Single.BottomRight
    Write-Host $footerLine
}

function Show-TimelineView {
    param($Tasks) # Filtered and sorted tasks
    Write-Header "Timeline View"

    $today = [datetime]::Today.Date
    $timelineGroups = @(
        @{ Name = "Overdue"; Color = (Get-ThemeProperty "Palette.ErrorFG"); Condition = { param($t) $t.DueDate -and ([datetime]::Parse($t.DueDate).Date -lt $today) -and -not $t.Completed } }
        @{ Name = "Today"; Color = (Get-ThemeProperty "Palette.WarningFG"); Condition = { param($t) $t.DueDate -and ([datetime]::Parse($t.DueDate).Date -eq $today) -and -not $t.Completed } }
        @{ Name = "Tomorrow"; Color = (Get-ThemeProperty "Palette.InfoFG"); Condition = { param($t) $t.DueDate -and ([datetime]::Parse($t.DueDate).Date -eq $today.AddDays(1)) -and -not $t.Completed } }
        @{ Name = "This Week (Next 7 Days)"; Color = (Get-ThemeProperty "Palette.AccentFG"); Condition = { param($t) $t.DueDate -and ([datetime]::Parse($t.DueDate).Date -gt $today.AddDays(1)) -and ([datetime]::Parse($t.DueDate).Date -le $today.AddDays(7)) -and -not $t.Completed } }
        @{ Name = "Next Week (Days 8-14)"; Color = (Get-ThemeProperty "Palette.SubtleFG"); Condition = { param($t) $t.DueDate -and ([datetime]::Parse($t.DueDate).Date -gt $today.AddDays(7)) -and ([datetime]::Parse($t.DueDate).Date -le $today.AddDays(14)) -and -not $t.Completed } }
        @{ Name = "Later"; Color = (Get-ThemeProperty "Palette.SubtleFG"); Condition = { param($t) $t.DueDate -and ([datetime]::Parse($t.DueDate).Date -gt $today.AddDays(14)) -and -not $t.Completed } }
        @{ Name = "No Due Date"; Color = (Get-ThemeProperty "Palette.SubtleFG"); Condition = { param($t) -not $t.DueDate -and -not $t.Completed } }
        @{ Name = "Recently Completed"; Color = (Get-ThemeProperty "DataTable.Highlight.Completed.FG"); Condition = { param($t) $t.Completed -and $t.CompletedDate -and ([datetime]::Parse($t.CompletedDate).Date -ge $today.AddDays(-$script:Data.Settings.ShowCompletedDays)) } }
    )

    foreach ($group in $timelineGroups) {
        $groupTasks = $Tasks | Where-Object { & $group.Condition $_ } | Sort-Object DueDate, Priority
        if ($groupTasks.Count -gt 0) {
            Write-Host "`n🗓️ $($group.Name) ($($groupTasks.Count))" -ForegroundColor $group.Color
            foreach ($task in $groupTasks) {
                $priorityInfo = Get-PriorityInfo $task.Priority
                $project = if ($task.ProjectKey) { (Get-ProjectOrTemplate $task.ProjectKey).Name } else { "" }
                $dueDateInfo = if ($task.DueDate) { (Format-TodoDate $task.DueDate) } else { "" }
                
                $taskLine = "  $($priorityInfo.Icon) $($task.Description)"
                if ($project) { $taskLine += " `o`($($project)`o`)" } # Small o for project marker
                if ($dueDateInfo -and $group.Name -ne "No Due Date") { $taskLine += " `o`($($dueDateInfo)`o`)" }
                if ($task.Completed) { $taskLine = Apply-PSStyle -Text $taskLine -FG (Get-ThemeProperty "DataTable.Highlight.Completed.FG")}
                
                Write-Host $taskLine
            }
        }
    }
}

function Show-ProjectTaskView {
    param($Tasks) # Filtered and sorted tasks
    Write-Header "Tasks Grouped by Project"

    $tasksByProject = $Tasks | Group-Object ProjectKey | Sort-Object Name

    foreach ($projectGroup in $tasksByProject) {
        $projectKey = $projectGroup.Name
        $project = if ($projectKey) { Get-ProjectOrTemplate $projectKey } else { $null }
        $projectName = if ($project) { $project.Name } else { "Tasks without a Project" }
        
        $activeCount = ($projectGroup.Group | Where-Object { -not $_.Completed }).Count
        $completedCount = ($projectGroup.Group | Where-Object { $_.Completed }).Count
        $totalInGroup = $projectGroup.Group.Count

        Write-Host "`n📁 $($projectName) " -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")
        Write-Host "($activeCount active / $completedCount completed of $totalInGroup)" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

        if ($totalInGroup -gt 0) {
            $projectProgress = [Math]::Round(($completedCount / $totalInGroup) * 100, 0)
            Draw-ProgressBar -Percent $projectProgress -Width 30 -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG") -BackgroundColor (Get-ThemeProperty "Palette.SubtleFG")
            Write-Host # Newline after progress bar
        }

        # Display tasks for this project using the standard list view format
        # This requires $projectGroup.Group to be passed to a table formatter
        $projectTaskData = $projectGroup.Group | ForEach-Object {
            $priorityInfo = Get-PriorityInfo $_.Priority
            $statusIcon = if ($_.Completed) { Apply-PSStyle -Text "✅" -FG (Get-ThemeProperty "DataTable.Highlight.Completed.FG") } else { $priorityInfo.Icon }
            [PSCustomObject]@{
                Icon        = $statusIcon
                Id          = $_.Id.Substring(0,6)
                Description = $_.Description
                DueDate     = if ($_.DueDate) { Format-TodoDate $_.DueDate } else { "-" }
                Priority    = $_.Priority.Substring(0, [Math]::Min($_.Priority.Length, 3))
                Progress    = if ($_.Completed) { "Done" } elseif ($_.Progress -gt 0) { "$($_.Progress)%" } else { "-" }
                Tags        = ($_.Tags -join ", ").ToString()
            }
        }
        $columns = @(
            @{Name="Icon"; Title="S"; Width=3}
            @{Name="Id"; Title="ID"; Width=7}
            @{Name="Description"; Title="Description"; Width=50; Wrap=$true}
            @{Name="DueDate"; Title="Due"; Width=12}
            @{Name="Priority"; Title="Pri"; Width=6}
            @{Name="Progress"; Title="Prog"; Width=5; Align="Right"}
            @{Name="Tags"; Title="Tags"; Width=20}
        )
        Format-TableUnicode -Data $projectTaskData -Columns $columns -NoHeader # No sub-headers for each project
    }
}

function Show-TaskStatistics {
    param($TasksToConsider) # Pass the set of tasks being currently viewed
   
    if (-not $TasksToConsider) { $TasksToConsider = @() } # Handle null input

    $stats = @{
        Total = $TasksToConsider.Count
        Completed = ($TasksToConsider | Where-Object { $_.Completed }).Count
        Critical = ($TasksToConsider | Where-Object { $_.Priority -eq "Critical" -and -not $_.Completed }).Count
        High = ($TasksToConsider | Where-Object { $_.Priority -eq "High" -and -not $_.Completed }).Count
        Medium = ($TasksToConsider | Where-Object { $_.Priority -eq "Medium" -and -not $_.Completed }).Count
        Low = ($TasksToConsider | Where-Object { $_.Priority -eq "Low" -and -not $_.Completed }).Count
        Overdue = ($TasksToConsider | Where-Object {
            $_.DueDate -and ([datetime]::Parse($_.DueDate).Date -lt [datetime]::Today.Date) -and -not $_.Completed
        }).Count
        DueToday = ($TasksToConsider | Where-Object {
            $_.DueDate -and ([datetime]::Parse($_.DueDate).Date -eq [datetime]::Today.Date) -and -not $_.Completed
        }).Count
        InProgress = ($TasksToConsider | Where-Object { $_.Progress -gt 0 -and $_.Progress -lt 100 -and -not $_.Completed }).Count
    }
   
    Write-Host "`n" + ("-" * ($Host.UI.RawUI.WindowSize.Width -2)) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
    $statLine = "  📊 Total: $($stats.Total) | ✅ Done: $($stats.Completed) | "
    if ($stats.Overdue -gt 0) { $statLine += Apply-PSStyle -Text "⚠️ Overdue: $($stats.Overdue) | " -FG (Get-ThemeProperty "Palette.ErrorFG")}
    if ($stats.DueToday -gt 0) { $statLine += Apply-PSStyle -Text "📅 Due Today: $($stats.DueToday) | " -FG (Get-ThemeProperty "Palette.WarningFG")}
    if ($stats.InProgress -gt 0) { $statLine += Apply-PSStyle -Text "🔄 In Prog: $($stats.InProgress) | " -FG (Get-ThemeProperty "Palette.AccentFG")}
    $statLine += "🔥 Crit: $($stats.Critical) | 🔴 High: $($stats.High) | 🟡 Med: $($stats.Medium) | 🟢 Low: $($stats.Low)"
    Write-Host $statLine
    Write-Host ("-" * ($Host.UI.RawUI.WindowSize.Width -2)) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")
}

function Show-ProjectsAndTemplates {
    # This UI function is now primarily for display. Core logic like Get-ProjectOrTemplate is in core-data.
    param([switch]$Simple) # $Simple switch might control verbosity or if header is shown
   
    if (-not $Simple) {
        Write-Header "Projects & Templates"
    }
    
    $activeProjects = @()
    $otherProjects = @()
    $templates = @()

    if ($script:Data -and $script:Data.Projects) {
        $allProjects = $script:Data.Projects.GetEnumerator() | Sort-Object { $_.Value.Name }
        $activeProjects = $allProjects | Where-Object { $_.Value.Status -eq "Active" }
        $otherProjects = $allProjects | Where-Object { $_.Value.Status -ne "Active" } | Sort-Object { $_.Value.Status }
    }
    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.TimeTrackerTemplates) {
        $templates = $script:Data.Settings.TimeTrackerTemplates.GetEnumerator() | Sort-Object { $_.Value.Name }
    }

    # Using Format-TableUnicode for a cleaner layout
    $projectDataToDisplay = @()

    # Active Projects
    if ($activeProjects.Count -gt 0) {
        $projectDataToDisplay += [PSCustomObject]@{ Section = "Active Projects"; Name = ""; Key = ""; Client = ""; Tasks = ""; Rate = "" } # Section Header
        foreach ($proj in $activeProjects) {
            $taskCount = if ($proj.Value.ActiveTasks) { $proj.Value.ActiveTasks } else { 0 }
            $taskDisplay = if ($taskCount -gt 0) { "$taskCount task$(if ($taskCount -ne 1) {'s'})" } else { "" }
            $rateDisplay = if ($proj.Value.BillingType -eq "Billable") { "`$$($proj.Value.Rate)/hr" } else { "Non-Bill" }
            $projectDataToDisplay += [PSCustomObject]@{ 
                Section = ""; 
                Name = $proj.Value.Name; 
                Key = "[$($proj.Key)]"; 
                Client = $proj.Value.Client;
                Tasks = $taskDisplay;
                Rate = $rateDisplay 
            }
        }
    } else {
         $projectDataToDisplay += [PSCustomObject]@{ Section = "Active Projects"; Name = "(None)"; Key = ""; Client = ""; Tasks = ""; Rate = "" }
    }
    $projectDataToDisplay += [PSCustomObject]@{ Section = ""; Name = ""; Key = ""; Client = ""; Tasks = ""; Rate = "" } # Spacer

    # Other Projects
    if ($otherProjects.Count -gt 0) {
        $projectDataToDisplay += [PSCustomObject]@{ Section = "Other Projects"; Name = ""; Key = ""; Client = ""; Tasks = ""; Rate = "" } # Section Header
        foreach ($proj in $otherProjects) {
            $projectDataToDisplay += [PSCustomObject]@{ 
                Section = "  ($($proj.Value.Status))"; # Indent status for visual grouping
                Name = $proj.Value.Name; 
                Key = "[$($proj.Key)]"; 
                Client = $proj.Value.Client;
                Tasks = ""; # No task count for non-active typically
                Rate = ""
            }
        }
    }
    $projectDataToDisplay += [PSCustomObject]@{ Section = ""; Name = ""; Key = ""; Client = ""; Tasks = ""; Rate = "" } # Spacer
    
    # Templates
    if ($templates.Count -gt 0) {
        $projectDataToDisplay += [PSCustomObject]@{ Section = "Templates"; Name = ""; Key = ""; Client = ""; Tasks = ""; Rate = "" } # Section Header
        foreach ($tmpl in $templates) {
            $projectDataToDisplay += [PSCustomObject]@{ 
                Section = ""; 
                Name = $tmpl.Value.Name; 
                Key = "[$($tmpl.Key)]"; 
                Client = "Internal";
                Tasks = "";
                Rate = ""
            }
        }
    }
    
    $columns = @(
        @{Name="Section"; Title=""; Width=18},
        @{Name="Key"; Title="Key"; Width=12},
        @{Name="Name"; Title="Name"; Width=30},
        @{Name="Client"; Title="Client"; Width=20},
        @{Name="Tasks"; Title="Active Tasks"; Width=15},
        @{Name="Rate"; Title="Rate/Type"; Width=12}
    )

    $rowColorCondition = {
        param($row)
        if ($row.Section -eq "Active Projects") { return Get-ThemeProperty "Palette.SuccessFG" } # Make section headers stand out
        if ($row.Section -eq "Other Projects") { return Get-ThemeProperty "Palette.WarningFG" }
        if ($row.Section -eq "Templates") { return Get-ThemeProperty "Palette.InfoFG" }
        if ($row.Key -match "\[ADM\]|\[MTG\]|\[TRN\]|\[BRK\]") { return Get-ThemeProperty "Palette.InfoFG" } # Template keys
        if ($row.Section -match "\(.*\)") { return Get-ThemeProperty "Palette.SubtleFG" } # Status like (On Hold)
        if ($row.Rate -match "Non-Bill") { return Get-ThemeProperty "Palette.SubtleFG" }
        return $null
    }
    
    Format-TableUnicode -Data $projectDataToDisplay -Columns $columns -NoHeader -BorderStyle "None" -RowColorCondition $rowColorCondition

}


#endregion
